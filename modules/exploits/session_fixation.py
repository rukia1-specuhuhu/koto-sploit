import requests
import random
import string
import re
import time
from bs4 import BeautifulSoup

class SessionFixationScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "TARGET_PARAM": "sessionid",
            "TIMEOUT": "10",
            "DELAY": "0",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "VERIFY_SSL": False,
            "FOLLOW_REDIRECTS": True,
            "TEST_LOGIN": False,
            "LOGIN_URL": "",
            "LOGIN_DATA": "",
            "SESSION_COOKIE_NAMES": ["sessionid", "session", "sid", "token", "auth", "auth_token", "session_token", "user_token", "phpsessid", "jsessionid", "aspsessionid"],
            "MAX_REDIRECTS": 5,
            "EXTRA_COOKIES": ""
        }
        
        self.session = requests.Session()
        self.vulnerabilities = []
        self.session_tokens = {}
        self.redirect_history = []
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_token(self, length=16):
        return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))
    
    def parse_headers(self):
        headers = {
            "User-Agent": self.get_option("USER_AGENT")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        return headers
    
    def parse_cookies(self):
        cookies = {}
        
        if self.get_option("EXTRA_COOKIES"):
            try:
                for cookie in self.get_option("EXTRA_COOKIES").split(";"):
                    if "=" in cookie:
                        key, value = cookie.split("=", 1)
                        cookies[key.strip()] = value.strip()
            except:
                pass
        
        return cookies
    
    def extract_session_tokens(self, response):
        tokens = {}
        
        cookie_header = response.headers.get('set-cookie', '')
        if cookie_header:
            for cookie in cookie_header.split(','):
                for session_name in self.get_option("SESSION_COOKIE_NAMES"):
                    if session_name.lower() in cookie.lower():
                        match = re.search(f'{session_name}=([^;]+)', cookie, re.IGNORECASE)
                        if match:
                            tokens[session_name] = match.group(1)
        
        return tokens
    
    def extract_form_tokens(self, response):
        tokens = {}
        soup = BeautifulSoup(response.text, 'html.parser')
        
        for input_tag in soup.find_all('input', {'type': 'hidden'}):
            name = input_tag.get('name', '').lower()
            value = input_tag.get('value', '')
            
            for session_name in self.get_option("SESSION_COOKIE_NAMES"):
                if session_name in name:
                    tokens[session_name] = value
        
        return tokens
    
    def extract_meta_tokens(self, response):
        tokens = {}
        soup = BeautifulSoup(response.text, 'html.parser')
        
        for meta_tag in soup.find_all('meta'):
            name = meta_tag.get('name', '').lower()
            content = meta_tag.get('content', '')
            
            for session_name in self.get_option("SESSION_COOKIE_NAMES"):
                if session_name in name:
                    tokens[session_name] = content
        
        return tokens
    
    def extract_url_tokens(self, url):
        tokens = {}
        parsed_url = requests.utils.urlparse(url)
        query_params = requests.utils.parse_qs(parsed_url.query)
        
        for session_name in self.get_option("SESSION_COOKIE_NAMES"):
            if session_name in query_params:
                tokens[session_name] = query_params[session_name][0]
        
        return tokens
    
    def test_session_fixation(self, url, initial_tokens):
        vulnerabilities = []
        
        for session_name, token_value in initial_tokens.items():
            if not token_value:
                continue
            
            test_data = {}
            if self.get_option("TEST_LOGIN") and self.get_option("LOGIN_URL") and self.get_option("LOGIN_DATA"):
                login_data = {}
                for param in self.get_option("LOGIN_DATA").split("&"):
                    if "=" in param:
                        key, value = param.split("=", 1)
                        login_data[key] = value
                
                login_headers = self.parse_headers()
                login_cookies = self.parse_cookies()
                login_cookies[session_name] = token_value
                
                try:
                    login_response = self.session.post(
                        self.get_option("LOGIN_URL"),
                        data=login_data,
                        headers=login_headers,
                        cookies=login_cookies,
                        timeout=int(self.get_option("TIMEOUT")),
                        verify=self.get_option("VERIFY_SSL"),
                        allow_redirects=self.get_option("FOLLOW_REDIRECTS")
                    )
                    
                    post_login_tokens = self.extract_session_tokens(login_response)
                    
                    if session_name in post_login_tokens and post_login_tokens[session_name] == token_value:
                        vulnerabilities.append({
                            "type": "Session Fixation",
                            "session_name": session_name,
                            "token": token_value,
                            "description": f"Session token '{session_name}' remains unchanged after login",
                            "severity": "High"
                        })
                    
                    if self.get_option("FOLLOW_REDIRECTS"):
                        final_response = self.session.get(
                            url,
                            headers=login_headers,
                            cookies=login_cookies,
                            timeout=int(self.get_option("TIMEOUT"),
                            verify=self.get_option("VERIFY_SSL"),
                            allow_redirects=False
                        )
                        
                        final_tokens = self.extract_session_tokens(final_response)
                        
                        if session_name in final_tokens and final_tokens[session_name] == token_value:
                            vulnerabilities.append({
                                "type": "Session Fixation",
                                "session_name": session_name,
                                "token": token_value,
                                "description": f"Session token '{session_name}' remains unchanged after login and redirect",
                                "severity": "High"
                            })
                
                except Exception:
                    pass
            
            test_cookies = self.parse_cookies()
            test_cookies[session_name] = token_value
            test_headers = self.parse_headers()
            
            try:
                test_response = self.session.get(
                    url,
                    headers=test_headers,
                    cookies=test_cookies,
                    timeout=int(self.get_option("TIMEOUT")),
                    verify=self.get_option("VERIFY_SSL"),
                    allow_redirects=False
                )
                
                if test_response.status_code == 200:
                    vulnerabilities.append({
                        "type": "Session Fixation",
                        "session_name": session_name,
                        "token": token_value,
                        "description": f"Server accepts arbitrary session token '{session_name}'",
                        "severity": "Medium"
                    })
                
                if 'location' in test_response.headers:
                    redirect_url = test_response.headers['location']
                    redirect_tokens = self.extract_url_tokens(redirect_url)
                    
                    if session_name in redirect_tokens and redirect_tokens[session_name] == token_value:
                        vulnerabilities.append({
                            "type": "Session Fixation",
                            "session_name": session_name,
                            "token": token_value,
                            "description": f"Session token '{session_name}' preserved in redirect URL",
                            "severity": "Medium"
                        })
            
            except Exception:
                pass
        
        return vulnerabilities
    
    def test_session_injection(self, url):
        vulnerabilities = []
        
        for session_name in self.get_option("SESSION_COOKIE_NAMES"):
            malicious_tokens = [
                self.generate_random_token(),
                "<script>alert('XSS')</script>",
                "'; DROP TABLE users; --",
                "../../../../etc/passwd",
                "{{7*7}}",
                "${7*7}",
                "%{7*7}"
            ]
            
            for malicious_token in malicious_tokens:
                test_cookies = self.parse_cookies()
                test_cookies[session_name] = malicious_token
                test_headers = self.parse_headers()
                
                try:
                    test_response = self.session.get(
                        url,
                        headers=test_headers,
                        cookies=test_cookies,
                        timeout=int(self.get_option("TIMEOUT")),
                        verify=self.get_option("VERIFY_SSL"),
                        allow_redirects=True
                    )
                    
                    if malicious_token in test_response.text:
                        vulnerabilities.append({
                            "type": "Session Injection",
                            "session_name": session_name,
                            "token": malicious_token,
                            "description": f"Session token '{session_name}' reflected in response",
                            "severity": "High"
                        })
                    
                    if test_response.status_code >= 500:
                        vulnerabilities.append({
                            "type": "Session Injection",
                            "session_name": session_name,
                            "token": malicious_token,
                            "description": f"Session token '{session_name}' causes server error",
                            "severity": "Medium"
                        })
                
                except Exception:
                    pass
        
        return vulnerabilities
    
    def test_session_hijacking(self, url):
        vulnerabilities = []
        
        test_cookies = self.parse_cookies()
        test_headers = self.parse_headers()
        
        try:
            initial_response = self.session.get(
                url,
                headers=test_headers,
                cookies=test_cookies,
                timeout=int(self.get_option("TIMEOUT")),
                verify=self.get_option("VERIFY_SSL"),
                allow_redirects=True
            )
            
            initial_tokens = self.extract_session_tokens(initial_response)
            initial_form_tokens = self.extract_form_tokens(initial_response)
            initial_meta_tokens = self.extract_meta_tokens(initial_response)
            initial_url_tokens = self.extract_url_tokens(url)
            
            all_tokens = {**initial_tokens, **initial_form_tokens, **initial_meta_tokens, **initial_url_tokens}
            
            for session_name, token_value in all_tokens.items():
                if not token_value:
                    continue
                
                hijack_cookies = self.parse_cookies()
                hijack_cookies[session_name] = token_value
                hijack_headers = self.parse_headers()
                
                try:
                    hijack_response = self.session.get(
                        url,
                        headers=hijack_headers,
                        cookies=hijack_cookies,
                        timeout=int(self.get_option("TIMEOUT")),
                        verify=self.get_option("VERIFY_SSL"),
                        allow_redirects=True
                    )
                    
                    if hijack_response.status_code == 200:
                        vulnerabilities.append({
                            "type": "Session Hijacking",
                            "session_name": session_name,
                            "token": token_value,
                            "description": f"Session token '{session_name}' can be reused",
                            "severity": "High"
                        })
                
                except Exception:
                    pass
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def run(self):
        url = self.get_option("URL")
        delay = int(self.get_option("DELAY"))
        
        if delay > 0:
            time.sleep(delay)
        
        vulnerabilities = []
        
        test_cookies = self.parse_cookies()
        test_headers = self.parse_headers()
        
        try:
            initial_response = self.session.get(
                url,
                headers=test_headers,
                cookies=test_cookies,
                timeout=int(self.get_option("TIMEOUT")),
                verify=self.get_option("VERIFY_SSL"),
                allow_redirects=True
            )
            
            initial_tokens = self.extract_session_tokens(initial_response)
            initial_form_tokens = self.extract_form_tokens(initial_response)
            initial_meta_tokens = self.extract_meta_tokens(initial_response)
            initial_url_tokens = self.extract_url_tokens(url)
            
            all_tokens = {**initial_tokens, **initial_form_tokens, **initial_meta_tokens, **initial_url_tokens}
            
            if all_tokens:
                fixation_vulns = self.test_session_fixation(url, all_tokens)
                vulnerabilities.extend(fixation_vulns)
            
            injection_vulns = self.test_session_injection(url)
            vulnerabilities.extend(injection_vulns)
            
            hijacking_vulns = self.test_session_hijacking(url)
            vulnerabilities.extend(hijacking_vulns)
        
        except Exception:
            pass
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} session vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No session vulnerabilities found"
            }
