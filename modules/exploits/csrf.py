import requests
from bs4 import BeautifulSoup
from colorama import Fore, Style
import re
import random
import string
import time
import base64
import json
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class CSRFDetector:
    def __init__(self):
        self.name = "CSRF Detector"
        self.description = "Cross-Site Request Forgery vulnerability scanner"
        self.author = "Red Team"
        self.options = {
            "URL": {
                "description": "Target URL to scan",
                "required": True,
                "value": ""
            },
            "CHECK_FORMS": {
                "description": "Check forms for CSRF tokens (true/false)",
                "required": False,
                "value": "true"
            },
            "CHECK_HEADERS": {
                "description": "Check anti-CSRF headers (true/false)",
                "required": False,
                "value": "true"
            },
            "TIMEOUT": {
                "description": "Request timeout in seconds",
                "required": False,
                "value": "10"
            },
            "BYPASS_CLOUDFLARE": {
                "description": "Enable Cloudflare bypass techniques (true/false)",
                "required": False,
                "value": "true"
            },
            "BYPASS_WAF": {
                "description": "Enable WAF bypass techniques (true/false)",
                "required": False,
                "value": "true"
            },
            "BYPASS_RATE_LIMIT": {
                "description": "Enable rate limit bypass (true/false)",
                "required": False,
                "value": "true"
            },
            "USER_AGENT_ROTATION": {
                "description": "Enable user agent rotation (true/false)",
                "required": False,
                "value": "true"
            },
            "PROXY_ROTATION": {
                "description": "Enable proxy rotation (true/false)",
                "required": False,
                "value": "false"
            },
            "DELAY_BETWEEN_REQUESTS": {
                "description": "Delay between requests in seconds",
                "required": False,
                "value": "0"
            },
            "STEALTH_MODE": {
                "description": "Enable stealth mode (true/false)",
                "required": False,
                "value": "true"
            }
        }
        
        self.csrf_tokens = [
            'csrf', 'csrftoken', 'csrf_token', 'csrf-token',
            'xsrf', 'xsrf-token', 'xsrf_token',
            '_token', 'token', 'authenticity_token',
            '__requestverificationtoken', 'anti-csrf-token',
            'anticsrf', 'csrfmiddlewaretoken', '_wpnonce',
            'nonce', 'securitytoken', 'formtoken'
        ]
        
        self.csrf_headers = [
            'X-CSRF-Token', 'X-XSRF-Token', 'X-CSRFToken',
            'X-Requested-With', 'Origin', 'Referer',
            'X-CSRFTOKEN', 'X-CSRF', 'CSRF-Token',
            'X-Anti-CSRF-Token', 'Anti-CSRF-Token'
        ]
        
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36'
        ]
        
        self.proxies = [
            'http://127.0.0.1:8080',
            'http://127.0.0.1:8888',
            'socks5://127.0.0.1:9050'
        ]
        
        self.cf_bypass_headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Cache-Control': 'max-age=0'
        }
        
        self.waf_bypass_techniques = [
            'random_case',
            'random_comment',
            'random_space',
            'random_encode',
            'fragment_identifier'
        ]
        
        self.rate_limit_bypass_techniques = [
            'random_delay',
            'header_rotation',
            'ip_rotation',
            'session_rotation'
        ]
    
    def run(self):
        url = self.options["URL"]["value"]
        check_forms = self.options["CHECK_FORMS"]["value"].lower() == "true"
        check_headers = self.options["CHECK_HEADERS"]["value"].lower() == "true"
        timeout = int(self.options["TIMEOUT"]["value"])
        bypass_cf = self.options["BYPASS_CLOUDFLARE"]["value"].lower() == "true"
        bypass_waf = self.options["BYPASS_WAF"]["value"].lower() == "true"
        bypass_rate = self.options["BYPASS_RATE_LIMIT"]["value"].lower() == "true"
        ua_rotation = self.options["USER_AGENT_ROTATION"]["value"].lower() == "true"
        proxy_rotation = self.options["PROXY_ROTATION"]["value"].lower() == "true"
        delay = float(self.options["DELAY_BETWEEN_REQUESTS"]["value"])
        stealth = self.options["STEALTH_MODE"]["value"].lower() == "true"
        
        if not url:
            print(f"{Fore.RED}[!] URL is required{Style.RESET_ALL}")
            return
        
        print(f"{Fore.CYAN}[*] Starting CSRF detection on: {url}{Style.RESET_ALL}\n")
        
        vulnerabilities = []
        
        try:
            session = requests.Session()
            
            if stealth:
                session.headers.update(self.cf_bypass_headers)
                
            if ua_rotation:
                session.headers.update({'User-Agent': random.choice(self.user_agents)})
                
            if proxy_rotation and self.proxies:
                session.proxies = {'http': random.choice(self.proxies), 'https': random.choice(self.proxies)}
                
            if bypass_cf:
                session.headers.update({
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'none',
                    'Sec-Fetch-User': '?1',
                    'Cache-Control': 'max-age=0'
                })
                
            if bypass_waf:
                waf_technique = random.choice(self.waf_bypass_techniques)
                if waf_technique == 'random_case':
                    url = self.random_case_bypass(url)
                elif waf_technique == 'random_comment':
                    url = self.random_comment_bypass(url)
                elif waf_technique == 'random_space':
                    url = self.random_space_bypass(url)
                elif waf_technique == 'random_encode':
                    url = self.random_encode_bypass(url)
                elif waf_technique == 'fragment_identifier':
                    url = self.fragment_identifier_bypass(url)
                    
            if bypass_rate:
                rate_technique = random.choice(self.rate_limit_bypass_techniques)
                if rate_technique == 'random_delay':
                    time.sleep(random.uniform(0.5, 2.0))
                elif rate_technique == 'header_rotation':
                    session.headers.update({'X-Forwarded-For': self.generate_random_ip()})
                elif rate_technique == 'ip_rotation':
                    if proxy_rotation and self.proxies:
                        session.proxies = {'http': random.choice(self.proxies), 'https': random.choice(self.proxies)}
                elif rate_technique == 'session_rotation':
                    session.cookies.clear()
                    
            if delay > 0:
                time.sleep(delay)
                
            response = session.get(url, timeout=timeout, verify=False, allow_redirects=True)
            
            if check_headers:
                header_vulns = self.check_csrf_headers(response)
                vulnerabilities.extend(header_vulns)
            
            if check_forms:
                form_vulns = self.check_forms(response, url, session)
                vulnerabilities.extend(form_vulns)
            
            self.display_results(vulnerabilities)
            
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[!] Request failed: {e}{Style.RESET_ALL}")
    
    def check_csrf_headers(self, response):
        vulns = []
        
        print(f"{Fore.YELLOW}[*] Checking anti-CSRF headers...{Style.RESET_ALL}")
        
        has_csrf_header = False
        for header in self.csrf_headers:
            if header in response.headers:
                has_csrf_header = True
                print(f"{Fore.GREEN}[+] Found anti-CSRF header: {header}{Style.RESET_ALL}")
        
        if not has_csrf_header:
            vulns.append({
                'type': 'Missing CSRF Headers',
                'severity': 'Medium',
                'description': 'No anti-CSRF headers found in response'
            })
            print(f"{Fore.RED}[-] No anti-CSRF headers detected{Style.RESET_ALL}")
        
        if 'X-Requested-With' not in response.headers:
            print(f"{Fore.YELLOW}[-] Missing X-Requested-With header{Style.RESET_ALL}")
        
        return vulns
    
    def check_forms(self, response, base_url, session):
        vulns = []
        
        print(f"\n{Fore.YELLOW}[*] Analyzing forms for CSRF tokens...{Style.RESET_ALL}")
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        if not forms:
            print(f"{Fore.CYAN}[*] No forms found on page{Style.RESET_ALL}")
            return vulns
        
        print(f"{Fore.CYAN}[*] Found {len(forms)} form(s){Style.RESET_ALL}\n")
        
        for idx, form in enumerate(forms, 1):
            action = form.get('action', '')
            method = form.get('method', 'get').upper()
            
            print(f"{Fore.CYAN}Form #{idx}:{Style.RESET_ALL}")
            print(f"  Action: {action or '(current page)'}")
            print(f"  Method: {method}")
            
            has_csrf_token = False
            
            inputs = form.find_all(['input', 'textarea'])
            for inp in inputs:
                name = inp.get('name', '').lower()
                input_type = inp.get('type', '').lower()
                
                if any(token in name for token in self.csrf_tokens):
                    has_csrf_token = True
                    print(f"{Fore.GREEN}  [+] CSRF token found: {inp.get('name')}{Style.RESET_ALL}")
                    break
                
                if input_type == 'hidden' and ('token' in name or 'csrf' in name):
                    has_csrf_token = True
                    print(f"{Fore.GREEN}  [+] Hidden CSRF token: {inp.get('name')}{Style.RESET_ALL}")
                    break
            
            if not has_csrf_token and method == 'POST':
                vulns.append({
                    'type': 'Missing CSRF Token',
                    'severity': 'High',
                    'description': f'POST form #{idx} lacks CSRF protection',
                    'action': action,
                    'method': method
                })
                print(f"{Fore.RED}  [-] VULNERABLE: No CSRF token in POST form{Style.RESET_ALL}")
                
                if action:
                    form_url = self.make_absolute_url(base_url, action)
                    print(f"{Fore.YELLOW}  [*] Attempting to exploit form...{Style.RESET_ALL}")
                    exploit_result = self.exploit_form(form_url, form, session)
                    if exploit_result:
                        print(f"{Fore.RED}  [+] Form successfully exploited!{Style.RESET_ALL}")
                    else:
                        print(f"{Fore.YELLOW}  [-] Exploit attempt failed{Style.RESET_ALL}")
            elif not has_csrf_token:
                print(f"{Fore.YELLOW}  [-] No CSRF token (GET form){Style.RESET_ALL}")
            
            print()
        
        return vulns
    
    def exploit_form(self, url, form, session):
        try:
            form_data = {}
            inputs = form.find_all(['input', 'textarea', 'select'])
            
            for inp in inputs:
                name = inp.get('name')
                if name:
                    input_type = inp.get('type', '').lower()
                    
                    if input_type in ['submit', 'button', 'image']:
                        continue
                    
                    if input_type == 'checkbox' or input_type == 'radio':
                        if inp.get('checked'):
                            form_data[name] = inp.get('value', 'on')
                    elif input_type == 'file':
                        form_data[name] = 'test.txt'
                    else:
                        form_data[name] = inp.get('value', '')
            
            if form.get('method', '').upper() == 'POST':
                response = session.post(url, data=form_data, verify=False, allow_redirects=True)
            else:
                response = session.get(url, params=form_data, verify=False, allow_redirects=True)
            
            return response.status_code < 400
            
        except Exception as e:
            print(f"{Fore.RED}[!] Exploit failed: {e}{Style.RESET_ALL}")
            return False
    
    def make_absolute_url(self, base_url, relative_url):
        if not relative_url:
            return base_url
            
        if relative_url.startswith(('http://', 'https://')):
            return relative_url
            
        from urllib.parse import urljoin
        return urljoin(base_url, relative_url)
    
    def display_results(self, vulnerabilities):
        print(f"\n{Fore.WHITE}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}CSRF Scan Results{Style.RESET_ALL}")
        print(f"{Fore.WHITE}{'='*60}{Style.RESET_ALL}\n")
        
        if not vulnerabilities:
            print(f"{Fore.GREEN}[+] No CSRF vulnerabilities detected{Style.RESET_ALL}")
            print(f"{Fore.GREEN}[+] Forms appear to have proper CSRF protection{Style.RESET_ALL}")
        else:
            print(f"{Fore.RED}[!] Found {len(vulnerabilities)} potential CSRF issue(s):{Style.RESET_ALL}\n")
            
            for vuln in vulnerabilities:
                severity_color = Fore.RED if vuln['severity'] == 'High' else Fore.YELLOW
                print(f"{severity_color}[{vuln['severity']}] {vuln['type']}{Style.RESET_ALL}")
                print(f"  Description: {vuln['description']}")
                if 'action' in vuln:
                    print(f"  Form Action: {vuln['action']}")
                print()
        
        print(f"{Fore.CYAN}[*] CSRF Protection Recommendations:{Style.RESET_ALL}")
        print(f"  1. Implement anti-CSRF tokens in all state-changing forms")
        print(f"  2. Use SameSite cookie attribute")
        print(f"  3. Verify Origin/Referer headers")
        print(f"  4. Implement double-submit cookie pattern")
        print(f"  5. Use framework-provided CSRF protection")
    
    def random_case_bypass(self, url):
        parsed_url = list(url)
        for i in range(len(parsed_url)):
            if random.random() < 0.3 and parsed_url[i].isalpha():
                if random.random() < 0.5:
                    parsed_url[i] = parsed_url[i].upper()
                else:
                    parsed_url[i] = parsed_url[i].lower()
        return ''.join(parsed_url)
    
    def random_comment_bypass(self, url):
        if '?' in url:
            return url + '/**/'
        else:
            return url + '/**/?'
    
    def random_space_bypass(self, url):
        if '?' in url:
            return url.replace('?', '?%20')
        else:
            return url + '/%20/'
    
    def random_encode_bypass(self, url):
        parsed_url = list(url)
        for i in range(len(parsed_url)):
            if random.random() < 0.1 and parsed_url[i].isalpha():
                parsed_url[i] = '%' + format(ord(parsed_url[i]), 'x')
        return ''.join(parsed_url)
    
    def fragment_identifier_bypass(self, url):
        if '#' in url:
            return url
        else:
            return url + '#' + ''.join(random.choices(string.ascii_letters + string.digits, k=8))
    
    def generate_random_ip(self):
        return '.'.join(str(random.randint(1, 255)) for _ in range(4))

if __name__ == "__main__":
    scanner = CSRFDetector()
    scanner.options["URL"]["value"] = input("Enter target URL: ")
    scanner.run()
