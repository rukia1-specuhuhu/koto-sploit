import requests
import re
from urllib.parse import urlparse, urljoin
from bs4 import BeautifulSoup

class JavaScriptHijackingScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "DEPTH": "2",
            "ANALYZE_DYNAMIC": True,
            "CHECK_CORS": True,
            "CHECK_CALLBACKS": True,
            "CHECK_JSONP": True,
            "CHECK_SENSITIVE_DATA": True,
            "CHECK_POSTMESSAGE": True
        }
        
        self.sensitive_patterns = [
            r'api[_-]?key',
            r'secret[_-]?key',
            r'password',
            r'token',
            r'session[_-]?id',
            r'auth[_-]?token',
            r'access[_-]?token',
            r'csrf[_-]?token',
            r'client[_-]?secret',
            r'authorization',
            r'bearertoken',
            r'x[_-]?api[_-]?key',
            r'x[_-]?auth[_-]?token'
        ]
        
        self.callback_patterns = [
            r'callback=',
            r'jsonp=',
            r'func=',
            r'cb=',
            r'jsoncallback=',
            r'callback=',
            r'c=',
            r'f='
        ]
        
        self.cors_patterns = [
            r'access-control-allow-origin',
            r'access-control-allow-credentials',
            r'access-control-allow-methods',
            r'access-control-allow-headers'
        ]
        
        self.jsonp_endpoints = [
            r'\.json\?callback=',
            r'\.jsonp\?',
            r'\.js\?callback=',
            r'\.api\?callback='
        ]
        
        self.vulnerable_callbacks = [
            'callback',
            'jsonp',
            'func',
            'cb',
            'jsoncallback',
            'c',
            'f',
            'jQuery',
            'angular',
            'vue',
            'react'
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def run(self):
        url = self.get_option("URL")
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        depth = int(self.get_option("DEPTH"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        vulnerabilities = []
        
        visited_urls = set()
        urls_to_scan = [url]
        
        for current_depth in range(depth):
            if not urls_to_scan:
                break
                
            current_urls = urls_to_scan
            urls_to_scan = []
            
            for target_url in current_urls:
                if target_url in visited_urls:
                    continue
                    
                visited_urls.add(target_url)
                
                if delay > 0:
                    time.sleep(delay)
                
                try:
                    response = requests.get(target_url, timeout=timeout, verify=False, headers=headers)
                    
                    if self.get_option("CHECK_CORS"):
                        cors_vulns = self.check_cors_vulnerabilities(response, target_url)
                        vulnerabilities.extend(cors_vulns)
                    
                    if self.get_option("CHECK_CALLBACKS"):
                        callback_vulns = self.check_callback_vulnerabilities(response, target_url)
                        vulnerabilities.extend(callback_vulns)
                    
                    if self.get_option("CHECK_JSONP"):
                        jsonp_vulns = self.check_jsonp_vulnerabilities(response, target_url)
                        vulnerabilities.extend(jsonp_vulns)
                    
                    if self.get_option("CHECK_SENSITIVE_DATA"):
                        data_vulns = self.check_sensitive_data_exposure(response, target_url)
                        vulnerabilities.extend(data_vulns)
                    
                    if self.get_option("CHECK_POSTMESSAGE"):
                        postmessage_vulns = self.check_postmessage_vulnerabilities(response, target_url)
                        vulnerabilities.extend(postmessage_vulns)
                    
                    if self.get_option("ANALYZE_DYNAMIC") and current_depth < depth - 1:
                        new_urls = self.extract_js_links(response, target_url)
                        urls_to_scan.extend(new_urls)
                
                except Exception:
                    continue
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} JavaScript hijacking vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No JavaScript hijacking vulnerabilities found"
            }
    
    def check_cors_vulnerabilities(self, response, url):
        vulnerabilities = []
        
        cors_headers = {}
        for header in response.headers:
            if any(pattern.lower() in header.lower() for pattern in self.cors_patterns):
                cors_headers[header] = response.headers[header]
        
        if 'Access-Control-Allow-Origin' in cors_headers:
            acao = cors_headers['Access-Control-Allow-Origin']
            
            if acao == '*':
                vulnerabilities.append({
                    "type": "CORS Misconfiguration",
                    "url": url,
                    "header": "Access-Control-Allow-Origin: *",
                    "severity": "High",
                    "description": "The resource allows access from any origin, which can lead to data theft"
                })
            
            elif 'null' in acao:
                vulnerabilities.append({
                    "type": "CORS Misconfiguration",
                    "url": url,
                    "header": f"Access-Control-Allow-Origin: {acao}",
                    "severity": "Medium",
                    "description": "The resource allows access from 'null' origin, which can be exploited"
                })
            
            elif 'Access-Control-Allow-Credentials' in cors_headers and cors_headers['Access-Control-Allow-Credentials'] == 'true':
                if acao != '*' and urlparse(url).netloc not in acao:
                    vulnerabilities.append({
                        "type": "CORS Misconfiguration with Credentials",
                        "url": url,
                        "header": f"Access-Control-Allow-Origin: {acao}, Access-Control-Allow-Credentials: true",
                        "severity": "High",
                        "description": "The resource allows credentials from unauthorized origins"
                    })
        
        return vulnerabilities
    
    def check_callback_vulnerabilities(self, response, url):
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        query_params = parsed_url.query.split('&')
        
        for param in query_params:
            if '=' in param:
                key, value = param.split('=', 1)
                
                if any(re.search(pattern, key.lower()) for pattern in self.callback_patterns):
                    if value in self.vulnerable_callbacks:
                        vulnerabilities.append({
                            "type": "Insecure Callback Function",
                            "url": url,
                            "parameter": key,
                            "value": value,
                            "severity": "Medium",
                            "description": f"The URL uses a predictable callback function '{value}' which can be hijacked"
                        })
        
        return vulnerabilities
    
    def check_jsonp_vulnerabilities(self, response, url):
        vulnerabilities = []
        
        for pattern in self.jsonp_endpoints:
            if re.search(pattern, url.lower()):
                vulnerabilities.append({
                    "type": "Potential JSONP Endpoint",
                    "url": url,
                    "severity": "Medium",
                    "description": "The URL appears to be a JSONP endpoint which might be vulnerable to hijacking"
                })
        
        content_type = response.headers.get('Content-Type', '').lower()
        
        if 'application/json' in content_type or 'text/javascript' in content_type:
            parsed_url = urlparse(url)
            
            if 'callback' in parsed_url.query or 'jsonp' in parsed_url.query:
                vulnerabilities.append({
                    "type": "JSONP Endpoint",
                    "url": url,
                    "severity": "Medium",
                    "description": "The endpoint returns JSON/JavaScript with a callback parameter, which might be vulnerable"
                })
        
        return vulnerabilities
    
    def check_sensitive_data_exposure(self, response, url):
        vulnerabilities = []
        
        content = response.text
        
        for pattern in self.sensitive_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            
            for match in matches:
                start = max(0, match.start() - 20)
                end = min(len(content), match.end() + 20)
                context = content[start:end].replace('\n', ' ').strip()
                
                vulnerabilities.append({
                    "type": "Sensitive Data Exposure",
                    "url": url,
                    "pattern": pattern,
                    "context": context,
                    "severity": "High",
                    "description": f"Potential sensitive data found: {pattern}"
                })
        
        return vulnerabilities
    
    def check_postmessage_vulnerabilities(self, response, url):
        vulnerabilities = []
        
        if 'postMessage' in response.text:
            vulnerabilities.append({
                "type": "Potential postMessage Vulnerability",
                "url": url,
                "severity": "Medium",
                "description": "The page uses postMessage which might be vulnerable to hijacking if not properly validated"
            })
        
        if 'addEventListener' in response.text and 'message' in response.text:
            vulnerabilities.append({
                "type": "Potential Message Event Listener",
                "url": url,
                "severity": "Medium",
                "description": "The page listens for message events which might be vulnerable to hijacking"
            })
        
        return vulnerabilities
    
    def extract_js_links(self, response, base_url):
        js_links = []
        
        soup = BeautifulSoup(response.text, 'html.parser')
        
        script_tags = soup.find_all('script')
        
        for script in script_tags:
            src = script.get('src')
            if src:
                if src.startswith('http'):
                    js_links.append(src)
                else:
                    js_links.append(urljoin(base_url, src))
        
        return js_links
