import requests
import urllib.parse
import re
import random
import string
from bs4 import BeautifulSoup

class PasswordResetPoisoningScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "USERNAME_FIELD": "username",
            "EMAIL_FIELD": "email",
            "METHOD": "POST",
            "TIMEOUT": "10",
            "DELAY": "2",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "HOST_HEADER": "",
            "X_FORWARDED_FOR": "",
            "REFERER": "",
            "RANDOM_USER_AGENT": False,
            "FOLLOW_REDIRECTS": True,
            "VERIFY_SSL": False
        }
        
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59"
        ]
        
        self.payloads = [
            "attacker.com",
            "evil.com",
            "malicious.com",
            "example.com",
            "test.com",
            "attacker-example.com",
            "evil-example.com",
            "malicious-example.com",
            "example-attacker.com",
            "test-evil.com",
            "attacker.com/reset",
            "evil.com/reset",
            "malicious.com/reset",
            "example.com/reset",
            "test.com/reset",
            "attacker.com/password",
            "evil.com/password",
            "malicious.com/password",
            "example.com/password",
            "test.com/password"
        ]
        
        self.host_headers = [
            "attacker.com",
            "evil.com",
            "malicious.com",
            "example.com",
            "test.com"
        ]
        
        self.x_forwarded_for = [
            "attacker.com",
            "evil.com",
            "malicious.com",
            "example.com",
            "test.com"
        ]
        
        self.indicators = [
            "password reset",
            "reset your password",
            "change your password",
            "reset link",
            "password reset link",
            "reset code",
            "reset token",
            "reset password",
            "new password",
            "confirm password",
            "set password"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_string(self, length=8):
        return ''.join(random.choice(string.ascii_lowercase) for i in range(length))
    
    def generate_random_email(self):
        username = self.generate_random_string()
        domain = random.choice(["gmail.com", "yahoo.com", "outlook.com", "example.com"])
        return f"{username}@{domain}"
    
    def extract_form_details(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        form = soup.find('form')
        
        if not form:
            return None, None, None
        
        action = form.get('action', '')
        method = form.get('method', 'get').upper()
        
        inputs = {}
        for input_tag in form.find_all('input'):
            name = input_tag.get('name')
            input_type = input_tag.get('type', 'text')
            value = input_tag.get('value', '')
            
            if name:
                inputs[name] = {
                    'type': input_type,
                    'value': value
                }
        
        return action, method, inputs
    
    def run(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        vulnerabilities = []
        
        try:
            session = requests.Session()
            
            if self.get_option("FOLLOW_REDIRECTS"):
                session.allow_redirects = True
            else:
                session.allow_redirects = False
            
            response = session.get(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
            
            form_action, form_method, form_inputs = self.extract_form_details(response.text)
            
            if form_action:
                if not form_action.startswith('http'):
                    if form_action.startswith('/'):
                        form_action = f"{urllib.parse.urlparse(url).scheme}://{urllib.parse.urlparse(url).netloc}{form_action}"
                    else:
                        form_action = f"{urllib.parse.urlparse(url).scheme}://{urllib.parse.urlparse(url).netloc}/{form_action}"
                
                target_url = form_action
                target_method = form_method if form_method else method
            else:
                target_url = url
                target_method = method
            
            username_field = self.get_option("USERNAME_FIELD")
            email_field = self.get_option("EMAIL_FIELD")
            
            for i, payload in enumerate(self.payloads):
                if delay > 0:
                    import time
                    time.sleep(delay)
                
                headers = self.prepare_headers()
                
                data = {}
                
                if form_inputs:
                    for input_name, input_details in form_inputs.items():
                        if input_name == username_field:
                            data[input_name] = self.generate_random_string()
                        elif input_name == email_field:
                            data[input_name] = f"{self.generate_random_string()}@{payload}"
                        else:
                            data[input_name] = input_details['value']
                else:
                    if username_field:
                        data[username_field] = self.generate_random_string()
                    if email_field:
                        data[email_field] = f"{self.generate_random_string()}@{payload}"
                
                if target_method == "GET":
                    if data:
                        query_string = urllib.parse.urlencode(data)
                        test_url = f"{target_url}?{query_string}"
                    else:
                        test_url = target_url
                    
                    response = session.get(test_url, headers=headers, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
                else:
                    response = session.post(target_url, data=data, headers=headers, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
                
                vulnerable, vuln_type = self.analyze_response(response, payload)
                
                if vulnerable:
                    vulnerabilities.append({
                        "payload": payload,
                        "type": vuln_type,
                        "url": target_url,
                        "method": target_method,
                        "data": data
                    })
            
            for i, host_header in enumerate(self.host_headers):
                if delay > 0:
                    import time
                    time.sleep(delay)
                
                headers = self.prepare_headers()
                headers["Host"] = host_header
                
                data = {}
                
                if form_inputs:
                    for input_name, input_details in form_inputs.items():
                        if input_name == username_field:
                            data[input_name] = self.generate_random_string()
                        elif input_name == email_field:
                            data[input_name] = self.generate_random_email()
                        else:
                            data[input_name] = input_details['value']
                else:
                    if username_field:
                        data[username_field] = self.generate_random_string()
                    if email_field:
                        data[email_field] = self.generate_random_email()
                
                if target_method == "GET":
                    if data:
                        query_string = urllib.parse.urlencode(data)
                        test_url = f"{target_url}?{query_string}"
                    else:
                        test_url = target_url
                    
                    response = session.get(test_url, headers=headers, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
                else:
                    response = session.post(target_url, data=data, headers=headers, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
                
                vulnerable, vuln_type = self.analyze_response(response, host_header, "Host Header")
                
                if vulnerable:
                    vulnerabilities.append({
                        "payload": host_header,
                        "type": vuln_type,
                        "url": target_url,
                        "method": target_method,
                        "data": data,
                        "header": "Host"
                    })
            
            for i, xff in enumerate(self.x_forwarded_for):
                if delay > 0:
                    import time
                    time.sleep(delay)
                
                headers = self.prepare_headers()
                headers["X-Forwarded-For"] = xff
                
                data = {}
                
                if form_inputs:
                    for input_name, input_details in form_inputs.items():
                        if input_name == username_field:
                            data[input_name] = self.generate_random_string()
                        elif input_name == email_field:
                            data[input_name] = self.generate_random_email()
                        else:
                            data[input_name] = input_details['value']
                else:
                    if username_field:
                        data[username_field] = self.generate_random_string()
                    if email_field:
                        data[email_field] = self.generate_random_email()
                
                if target_method == "GET":
                    if data:
                        query_string = urllib.parse.urlencode(data)
                        test_url = f"{target_url}?{query_string}"
                    else:
                        test_url = target_url
                    
                    response = session.get(test_url, headers=headers, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
                else:
                    response = session.post(target_url, data=data, headers=headers, timeout=timeout, verify=self.get_option("VERIFY_SSL"))
                
                vulnerable, vuln_type = self.analyze_response(response, xff, "X-Forwarded-For Header")
                
                if vulnerable:
                    vulnerabilities.append({
                        "payload": xff,
                        "type": vuln_type,
                        "url": target_url,
                        "method": target_method,
                        "data": data,
                        "header": "X-Forwarded-For"
                    })
            
            if vulnerabilities:
                return {
                    "success": True,
                    "message": f"Found {len(vulnerabilities)} password reset poisoning vulnerabilities",
                    "vulnerabilities": vulnerabilities
                }
            else:
                return {
                    "success": True,
                    "message": "No password reset poisoning vulnerabilities found"
                }
        
        except Exception as e:
            return {
                "success": False,
                "message": f"Error during scanning: {str(e)}"
            }
    
    def prepare_headers(self):
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("RANDOM_USER_AGENT"):
            headers["User-Agent"] = random.choice(self.user_agents)
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        if self.get_option("REFERER"):
            headers["Referer"] = self.get_option("REFERER")
        
        if self.get_option("HOST_HEADER"):
            headers["Host"] = self.get_option("HOST_HEADER")
        
        if self.get_option("X_FORWARDED_FOR"):
            headers["X-Forwarded-For"] = self.get_option("X_FORWARDED_FOR")
        
        return headers
    
    def analyze_response(self, response, payload, header_type="Email Parameter"):
        vulnerable = False
        vuln_type = ""
        
        response_text = response.text.lower()
        
        for indicator in self.indicators:
            if indicator in response_text:
                vulnerable = True
                vuln_type = f"Password Reset Poisoning via {header_type}"
                break
        
        if not vulnerable:
            if "email sent" in response_text or "check your email" in response_text or "reset link sent" in response_text:
                vulnerable = True
                vuln_type = f"Potential Password Reset Poisoning via {header_type}"
        
        if "invalid" in response_text or "error" in response_text or "failed" in response_text:
            vulnerable = False
        
        return vulnerable, vuln_type
