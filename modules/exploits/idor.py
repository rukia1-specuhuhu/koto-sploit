import requests
import urllib.parse
import re
import random
import string
from bs4 import BeautifulSoup

class IDORScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "TARGET_PARAM": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "AUTH_TOKEN": "",
            "TEST_SEQUENTIAL": True,
            "TEST_RANDOM": True,
            "TEST_ENUMERATION": True,
            "TEST_FORCED_BROWSING": True,
            "MAX_SEQUENTIAL": 10,
            "MAX_RANDOM": 10,
            "COMMON_ENDPOINTS": "",
            "RESPONSE_DIFF_THRESHOLD": 30,
            "FOLLOW_REDIRECTS": False
        }
        
        self.common_params = [
            "id", "user_id", "userid", "uid", "account", "account_id", "acc",
            "file", "file_id", "doc", "doc_id", "document", "document_id",
            "order", "order_id", "order_number", "order_no",
            "item", "item_id", "product", "product_id",
            "customer", "customer_id", "client", "client_id",
            "post", "post_id", "article", "article_id",
            "message", "message_id", "msg", "msg_id",
            "comment", "comment_id",
            "category", "category_id", "cat", "cat_id",
            "page", "page_id",
            "event", "event_id",
            "ticket", "ticket_id",
            "booking", "booking_id",
            "payment", "payment_id",
            "transaction", "transaction_id",
            "session", "session_id",
            "profile", "profile_id",
            "group", "group_id",
            "role", "role_id",
            "permission", "permission_id",
            "report", "report_id",
            "invoice", "invoice_id",
            "receipt", "receipt_id",
            "note", "note_id",
            "task", "task_id",
            "project", "project_id",
            "folder", "folder_id",
            "image", "image_id",
            "video", "video_id",
            "record", "record_id"
        ]
        
        self.common_endpoints = [
            "/api/users/{id}",
            "/api/user/{id}",
            "/api/accounts/{id}",
            "/api/account/{id}",
            "/api/customers/{id}",
            "/api/customer/{id}",
            "/api/clients/{id}",
            "/api/client/{id}",
            "/api/orders/{id}",
            "/api/order/{id}",
            "/api/items/{id}",
            "/api/item/{id}",
            "/api/products/{id}",
            "/api/product/{id}",
            "/api/files/{id}",
            "/api/file/{id}",
            "/api/documents/{id}",
            "/api/document/{id}",
            "/api/posts/{id}",
            "/api/post/{id}",
            "/api/articles/{id}",
            "/api/article/{id}",
            "/api/messages/{id}",
            "/api/message/{id}",
            "/api/comments/{id}",
            "/api/comment/{id}",
            "/api/categories/{id}",
            "/api/category/{id}",
            "/api/pages/{id}",
            "/api/page/{id}",
            "/api/events/{id}",
            "/api/event/{id}",
            "/api/tickets/{id}",
            "/api/ticket/{id}",
            "/api/bookings/{id}",
            "/api/booking/{id}",
            "/api/payments/{id}",
            "/api/payment/{id}",
            "/api/transactions/{id}",
            "/api/transaction/{id}",
            "/api/sessions/{id}",
            "/api/session/{id}",
            "/api/profiles/{id}",
            "/api/profile/{id}",
            "/api/groups/{id}",
            "/api/group/{id}",
            "/api/roles/{id}",
            "/api/role/{id}",
            "/api/permissions/{id}",
            "/api/permission/{id}",
            "/api/reports/{id}",
            "/api/report/{id}",
            "/api/invoices/{id}",
            "/api/invoice/{id}",
            "/api/receipts/{id}",
            "/api/receipt/{id}",
            "/api/notes/{id}",
            "/api/note/{id}",
            "/api/tasks/{id}",
            "/api/task/{id}",
            "/api/projects/{id}",
            "/api/project/{id}",
            "/api/folders/{id}",
            "/api/folder/{id}",
            "/api/images/{id}",
            "/api/image/{id}",
            "/api/videos/{id}",
            "/api/video/{id}",
            "/api/records/{id}",
            "/api/record/{id}",
            "/users/{id}",
            "/user/{id}",
            "/accounts/{id}",
            "/account/{id}",
            "/customers/{id}",
            "/customer/{id}",
            "/clients/{id}",
            "/client/{id}",
            "/orders/{id}",
            "/order/{id}",
            "/items/{id}",
            "/item/{id}",
            "/products/{id}",
            "/product/{id}",
            "/files/{id}",
            "/file/{id}",
            "/documents/{id}",
            "/document/{id}",
            "/posts/{id}",
            "/post/{id}",
            "/articles/{id}",
            "/article/{id}",
            "/messages/{id}",
            "/message/{id}",
            "/comments/{id}",
            "/comment/{id}",
            "/categories/{id}",
            "/category/{id}",
            "/pages/{id}",
            "/page/{id}",
            "/events/{id}",
            "/event/{id}",
            "/tickets/{id}",
            "/ticket/{id}",
            "/bookings/{id}",
            "/booking/{id}",
            "/payments/{id}",
            "/payment/{id}",
            "/transactions/{id}",
            "/transaction/{id}",
            "/sessions/{id}",
            "/session/{id}",
            "/profiles/{id}",
            "/profile/{id}",
            "/groups/{id}",
            "/group/{id}",
            "/roles/{id}",
            "/role/{id}",
            "/permissions/{id}",
            "/permission/{id}",
            "/reports/{id}",
            "/report/{id}",
            "/invoices/{id}",
            "/invoice/{id}",
            "/receipts/{id}",
            "/receipt/{id}",
            "/notes/{id}",
            "/note/{id}",
            "/tasks/{id}",
            "/task/{id}",
            "/projects/{id}",
            "/project/{id}",
            "/folders/{id}",
            "/folder/{id}",
            "/images/{id}",
            "/image/{id}",
            "/videos/{id}",
            "/video/{id}",
            "/records/{id}",
            "/record/{id}"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_id(self, length=8):
        return ''.join(random.choices(string.digits, k=length))
    
    def generate_random_string_id(self, length=8):
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))
    
    def extract_ids_from_response(self, response_text):
        ids = []
        pattern = r'\b[0-9]{1,10}\b'
        matches = re.findall(pattern, response_text)
        for match in matches:
            if match not in ids:
                ids.append(match)
        return ids
    
    def extract_uuids_from_response(self, response_text):
        uuids = []
        pattern = r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b'
        matches = re.findall(pattern, response_text)
        for match in matches:
            if match not in uuids:
                uuids.append(match)
        return uuids
    
    def extract_string_ids_from_response(self, response_text):
        ids = []
        pattern = r'\b[a-zA-Z0-9]{8,20}\b'
        matches = re.findall(pattern, response_text)
        for match in matches:
            if match not in ids and len(match) >= 8:
                ids.append(match)
        return ids
    
    def calculate_response_difference(self, response1, response2):
        if not response1 or not response2:
            return 0
        
        len1 = len(response1)
        len2 = len(response2)
        
        if len1 == 0 or len2 == 0:
            return 100
        
        diff = abs(len1 - len2) / max(len1, len2) * 100
        return diff
    
    def run(self):
        url = self.get_option("URL")
        target_param = self.get_option("TARGET_PARAM")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        if self.get_option("AUTH_TOKEN"):
            headers["Authorization"] = f"Bearer {self.get_option('AUTH_TOKEN')}"
        
        vulnerabilities = []
        
        if target_param:
            vulnerabilities.extend(self.test_parameter_idor(url, target_param, method, timeout, delay, headers))
        
        if self.get_option("TEST_SEQUENTIAL"):
            vulnerabilities.extend(self.test_sequential_idor(url, method, timeout, delay, headers))
        
        if self.get_option("TEST_RANDOM"):
            vulnerabilities.extend(self.test_random_idor(url, method, timeout, delay, headers))
        
        if self.get_option("TEST_ENUMERATION"):
            vulnerabilities.extend(self.test_enumeration_idor(url, method, timeout, delay, headers))
        
        if self.get_option("TEST_FORCED_BROWSING"):
            vulnerabilities.extend(self.test_forced_browsing_idor(url, method, timeout, delay, headers))
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} potential IDOR vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No IDOR vulnerabilities found"
            }
    
    def test_parameter_idor(self, url, target_param, method, timeout, delay, headers):
        vulnerabilities = []
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            else:
                response = requests.post(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            
            original_response = response.text
            original_status = response.status_code
            
            if delay > 0:
                time.sleep(delay)
            
            test_ids = ["1", "2", "admin", "administrator", "test", "guest", "0", "-1", "99999"]
            
            for test_id in test_ids:
                if delay > 0:
                    time.sleep(delay)
                
                if method == "GET":
                    if "?" in url:
                        test_url = f"{url}&{target_param}={test_id}"
                    else:
                        test_url = f"{url}?{target_param}={test_id}"
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                else:
                    params = {target_param: test_id}
                    response = requests.post(url, data=params, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                
                difference = self.calculate_response_difference(original_response, response.text)
                
                if difference > self.get_option("RESPONSE_DIFF_THRESHOLD") and response.status_code == original_status:
                    vulnerabilities.append({
                        "type": "Parameter Manipulation",
                        "parameter": target_param,
                        "payload": test_id,
                        "url": response.url,
                        "status_code": response.status_code,
                        "difference": difference
                    })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def test_sequential_idor(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            else:
                response = requests.post(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            
            original_response = response.text
            original_status = response.status_code
            
            ids = self.extract_ids_from_response(original_response)
            
            if not ids:
                return vulnerabilities
            
            base_id = ids[0]
            
            if delay > 0:
                time.sleep(delay)
            
            for i in range(1, int(self.get_option("MAX_SEQUENTIAL")) + 1):
                test_id = str(int(base_id) + i)
                
                if delay > 0:
                    time.sleep(delay)
                
                test_url = url.replace(base_id, test_id)
                
                if method == "GET":
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                else:
                    response = requests.post(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                
                difference = self.calculate_response_difference(original_response, response.text)
                
                if difference > self.get_option("RESPONSE_DIFF_THRESHOLD") and response.status_code == original_status:
                    vulnerabilities.append({
                        "type": "Sequential ID",
                        "original_id": base_id,
                        "tested_id": test_id,
                        "url": response.url,
                        "status_code": response.status_code,
                        "difference": difference
                    })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def test_random_idor(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            else:
                response = requests.post(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            
            original_response = response.text
            original_status = response.status_code
            
            if delay > 0:
                time.sleep(delay)
            
            for _ in range(int(self.get_option("MAX_RANDOM"))):
                test_id = self.generate_random_id()
                
                if delay > 0:
                    time.sleep(delay)
                
                test_url = url
                
                for param in self.common_params:
                    if param in url:
                        test_url = re.sub(rf'{param}=[^&]*', f'{param}={test_id}', test_url)
                        break
                
                if test_url == url:
                    if method == "GET":
                        if "?" in url:
                            test_url = f"{url}&id={test_id}"
                        else:
                            test_url = f"{url}?id={test_id}"
                    else:
                        test_url = url
                
                if method == "GET":
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                else:
                    params = {"id": test_id}
                    response = requests.post(test_url, data=params, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                
                difference = self.calculate_response_difference(original_response, response.text)
                
                if difference > self.get_option("RESPONSE_DIFF_THRESHOLD") and response.status_code == original_status:
                    vulnerabilities.append({
                        "type": "Random ID",
                        "tested_id": test_id,
                        "url": response.url,
                        "status_code": response.status_code,
                        "difference": difference
                    })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def test_enumeration_idor(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            else:
                response = requests.post(url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
            
            original_response = response.text
            original_status = response.status_code
            
            ids = self.extract_ids_from_response(original_response)
            uuids = self.extract_uuids_from_response(original_response)
            string_ids = self.extract_string_ids_from_response(original_response)
            
            if delay > 0:
                time.sleep(delay)
            
            for test_id in ids[:5]:
                if delay > 0:
                    time.sleep(delay)
                
                test_url = url
                
                for param in self.common_params:
                    if param in url:
                        test_url = re.sub(rf'{param}=[^&]*', f'{param}={test_id}', test_url)
                        break
                
                if test_url == url:
                    if method == "GET":
                        if "?" in url:
                            test_url = f"{url}&id={test_id}"
                        else:
                            test_url = f"{url}?id={test_id}"
                    else:
                        test_url = url
                
                if method == "GET":
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                else:
                    params = {"id": test_id}
                    response = requests.post(test_url, data=params, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                
                difference = self.calculate_response_difference(original_response, response.text)
                
                if difference > self.get_option("RESPONSE_DIFF_THRESHOLD") and response.status_code == original_status:
                    vulnerabilities.append({
                        "type": "ID Enumeration",
                        "tested_id": test_id,
                        "url": response.url,
                        "status_code": response.status_code,
                        "difference": difference
                    })
            
            for test_id in uuids[:5]:
                if delay > 0:
                    time.sleep(delay)
                
                test_url = url
                
                for param in self.common_params:
                    if param in url:
                        test_url = re.sub(rf'{param}=[^&]*', f'{param}={test_id}', test_url)
                        break
                
                if test_url == url:
                    if method == "GET":
                        if "?" in url:
                            test_url = f"{url}&id={test_id}"
                        else:
                            test_url = f"{url}?id={test_id}"
                    else:
                        test_url = url
                
                if method == "GET":
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                else:
                    params = {"id": test_id}
                    response = requests.post(test_url, data=params, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                
                difference = self.calculate_response_difference(original_response, response.text)
                
                if difference > self.get_option("RESPONSE_DIFF_THRESHOLD") and response.status_code == original_status:
                    vulnerabilities.append({
                        "type": "UUID Enumeration",
                        "tested_id": test_id,
                        "url": response.url,
                        "status_code": response.status_code,
                        "difference": difference
                    })
            
            for test_id in string_ids[:5]:
                if delay > 0:
                    time.sleep(delay)
                
                test_url = url
                
                for param in self.common_params:
                    if param in url:
                        test_url = re.sub(rf'{param}=[^&]*', f'{param}={test_id}', test_url)
                        break
                
                if test_url == url:
                    if method == "GET":
                        if "?" in url:
                            test_url = f"{url}&id={test_id}"
                        else:
                            test_url = f"{url}?id={test_id}"
                    else:
                        test_url = url
                
                if method == "GET":
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                else:
                    params = {"id": test_id}
                    response = requests.post(test_url, data=params, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                
                difference = self.calculate_response_difference(original_response, response.text)
                
                if difference > self.get_option("RESPONSE_DIFF_THRESHOLD") and response.status_code == original_status:
                    vulnerabilities.append({
                        "type": "String ID Enumeration",
                        "tested_id": test_id,
                        "url": response.url,
                        "status_code": response.status_code,
                        "difference": difference
                    })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def test_forced_browsing_idor(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        try:
            base_url = url.split('?')[0]
            
            endpoints = self.common_endpoints
            
            if self.get_option("COMMON_ENDPOINTS"):
                custom_endpoints = self.get_option("COMMON_ENDPOINTS").split(",")
                endpoints.extend(custom_endpoints)
            
            if delay > 0:
                time.sleep(delay)
            
            for endpoint in endpoints[:20]:
                if delay > 0:
                    time.sleep(delay)
                
                test_ids = ["1", "2", "admin", "test", "guest"]
                
                for test_id in test_ids:
                    test_url = base_url + endpoint.replace("{id}", test_id)
                    
                    if method == "GET":
                        response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                    else:
                        response = requests.post(test_url, timeout=timeout, verify=False, headers=headers, allow_redirects=self.get_option("FOLLOW_REDIRECTS"))
                    
                    if response.status_code == 200:
                        vulnerabilities.append({
                            "type": "Forced Browsing",
                            "endpoint": endpoint,
                            "tested_id": test_id,
                            "url": response.url,
                            "status_code": response.status_code
                        })
        
        except Exception:
            pass
        
        return vulnerabilities
