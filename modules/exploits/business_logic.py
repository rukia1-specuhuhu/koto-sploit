import requests
import json
import re
import time
import random
import urllib.parse
from bs4 import BeautifulSoup

class BusinessLogicScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "DATA": "",
            "AUTH_TOKEN": "",
            "DEPTH": "2",
            "CRAWL": "false",
            "VERBOSE": "false"
        }
        
        self.vulnerabilities = []
        self.session = requests.Session()
        self.crawled_urls = set()
        
        self.business_logic_tests = [
            {
                "name": "Price Manipulation",
                "description": "Test for price manipulation vulnerabilities",
                "test": self.test_price_manipulation
            },
            {
                "name": "Parameter Tampering",
                "description": "Test for parameter tampering vulnerabilities",
                "test": self.test_parameter_tampering
            },
            {
                "name": "Privilege Escalation",
                "description": "Test for privilege escalation vulnerabilities",
                "test": self.test_privilege_escalation
            },
            {
                "name": "IDOR",
                "description": "Test for Insecure Direct Object Reference vulnerabilities",
                "test": self.test_idor
            },
            {
                "name": "Function Bypass",
                "description": "Test for function bypass vulnerabilities",
                "test": self.test_function_bypass
            },
            {
                "name": "Excessive Permissions",
                "description": "Test for excessive permissions vulnerabilities",
                "test": self.test_excessive_permissions
            },
            {
                "name": "Transaction Abuse",
                "description": "Test for transaction abuse vulnerabilities",
                "test": self.test_transaction_abuse
            },
            {
                "name": "Process Flaws",
                "description": "Test for process flow vulnerabilities",
                "test": self.test_process_flaws
            }
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def prepare_headers(self):
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        if self.get_option("AUTH_TOKEN"):
            headers["Authorization"] = f"Bearer {self.get_option('AUTH_TOKEN')}"
        
        return headers
    
    def send_request(self, url, method="GET", data=None, params=None):
        headers = self.prepare_headers()
        timeout = int(self.get_option("TIMEOUT"))
        
        try:
            if method.upper() == "GET":
                response = self.session.get(url, headers=headers, timeout=timeout, params=params, verify=False)
            elif method.upper() == "POST":
                if isinstance(data, str):
                    response = self.session.post(url, headers=headers, timeout=timeout, data=data, verify=False)
                else:
                    response = self.session.post(url, headers=headers, timeout=timeout, json=data, verify=False)
            elif method.upper() == "PUT":
                if isinstance(data, str):
                    response = self.session.put(url, headers=headers, timeout=timeout, data=data, verify=False)
                else:
                    response = self.session.put(url, headers=headers, timeout=timeout, json=data, verify=False)
            elif method.upper() == "DELETE":
                response = self.session.delete(url, headers=headers, timeout=timeout, verify=False)
            else:
                response = self.session.request(method, url, headers=headers, timeout=timeout, data=data, params=params, verify=False)
            
            return response
        except Exception as e:
            return None
    
    def crawl_url(self, url, depth=0):
        if depth > int(self.get_option("DEPTH")) or url in self.crawled_urls:
            return
        
        self.crawled_urls.add(url)
        response = self.send_request(url)
        
        if not response:
            return
        
        if depth < int(self.get_option("DEPTH")):
            soup = BeautifulSoup(response.text, 'html.parser')
            for link in soup.find_all('a'):
                href = link.get('href')
                if href and href.startswith('http'):
                    self.crawl_url(href, depth + 1)
    
    def test_price_manipulation(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        if "cart" not in url.lower() and "checkout" not in url.lower() and "order" not in url.lower():
            return
        
        response = self.send_request(url, method)
        
        if not response:
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        price_elements = soup.find_all(['span', 'div'], class_=re.compile(r'price|cost|amount', re.I))
        
        if not price_elements:
            return
        
        for element in price_elements:
            price_text = element.get_text().strip()
            price_match = re.search(r'(\d+\.?\d*)', price_text)
            
            if price_match:
                original_price = float(price_match.group(1))
                
                if method.upper() == "GET":
                    test_url = f"{url}?price=0.01"
                    test_response = self.send_request(test_url, method)
                else:
                    data = {"price": "0.01"}
                    test_response = self.send_request(url, method, data=data)
                
                if test_response:
                    test_soup = BeautifulSoup(test_response.text, 'html.parser')
                    test_price_elements = test_soup.find_all(['span', 'div'], class_=re.compile(r'price|cost|amount', re.I))
                    
                    for test_element in test_price_elements:
                        test_price_text = test_element.get_text().strip()
                        test_price_match = re.search(r'(\d+\.?\d*)', test_price_text)
                        
                        if test_price_match:
                            new_price = float(test_price_match.group(1))
                            if new_price < original_price:
                                self.vulnerabilities.append({
                                    "type": "Price Manipulation",
                                    "url": url,
                                    "description": f"Price can be manipulated from {original_price} to {new_price}",
                                    "payload": "price=0.01"
                                })
                                return
    
    def test_parameter_tampering(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        response = self.send_request(url, method)
        
        if not response:
            return
        
        if method.upper() == "GET":
            params = {}
            test_params = {
                "admin": "true",
                "role": "admin",
                "debug": "true",
                "test": "true",
                " bypass": "true",
                "force": "true",
                "override": "true"
            }
            
            for param, value in test_params.items():
                test_url = f"{url}?{param}={value}"
                test_response = self.send_request(test_url, method)
                
                if test_response and ("admin" in test_response.text.lower() or "debug" in test_response.text.lower()):
                    self.vulnerabilities.append({
                        "type": "Parameter Tampering",
                        "url": url,
                        "description": f"Parameter {param} can be tampered to gain additional privileges",
                        "payload": f"{param}={value}"
                    })
        else:
            data = {}
            test_data = {
                "admin": "true",
                "role": "admin",
                "debug": "true",
                "test": "true",
                " bypass": "true",
                "force": "true",
                "override": "true"
            }
            
            for param, value in test_data.items():
                test_data = {param: value}
                test_response = self.send_request(url, method, data=test_data)
                
                if test_response and ("admin" in test_response.text.lower() or "debug" in test_response.text.lower()):
                    self.vulnerabilities.append({
                        "type": "Parameter Tampering",
                        "url": url,
                        "description": f"Parameter {param} can be tampered to gain additional privileges",
                        "payload": f"{param}={value}"
                    })
    
    def test_privilege_escalation(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        if "admin" in url.lower() or "dashboard" in url.lower() or "manage" in url.lower():
            return
        
        admin_urls = [
            url.replace("user", "admin"),
            url.replace("profile", "admin"),
            url.replace("dashboard", "admin"),
            url + "/admin",
            url + "/admin/dashboard",
            url + "/admin/panel"
        ]
        
        for admin_url in admin_urls:
            response = self.send_request(admin_url, method)
            
            if response and response.status_code == 200:
                self.vulnerabilities.append({
                    "type": "Privilege Escalation",
                    "url": admin_url,
                    "description": "Access to admin functionality without proper authorization",
                    "payload": "URL manipulation to access admin area"
                })
                return
    
    def test_idor(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        id_patterns = [
            r'user_id=(\d+)',
            r'id=(\d+)',
            r'account_id=(\d+)',
            r'profile_id=(\d+)',
            r'item_id=(\d+)',
            r'order_id=(\d+)',
            r'file_id=(\d+)',
            r'document_id=(\d+)'
        ]
        
        for pattern in id_patterns:
            match = re.search(pattern, url)
            if match:
                original_id = match.group(1)
                new_id = str(int(original_id) + 1)
                
                test_url = re.sub(pattern, f'{pattern.split("=")[0]}={new_id}', url)
                response = self.send_request(test_url, method)
                
                if response and response.status_code == 200:
                    self.vulnerabilities.append({
                        "type": "IDOR",
                        "url": test_url,
                        "description": f"Access to resource by changing ID from {original_id} to {new_id}",
                        "payload": f"Changed ID parameter from {original_id} to {new_id}"
                    })
                    return
    
    def test_function_bypass(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        bypass_tests = [
            {"param": "disabled", "value": "false"},
            {"param": "enabled", "value": "true"},
            {"param": "locked", "value": "false"},
            {"param": "active", "value": "true"},
            {"param": "blocked", "value": "false"},
            {"param": "verified", "value": "true"}
        ]
        
        for test in bypass_tests:
            if method.upper() == "GET":
                test_url = f"{url}?{test['param']}={test['value']}"
                response = self.send_request(test_url, method)
            else:
                data = {test['param']: test['value']}
                response = self.send_request(url, method, data=data)
            
            if response and "success" in response.text.lower() or "enabled" in response.text.lower():
                self.vulnerabilities.append({
                    "type": "Function Bypass",
                    "url": url,
                    "description": f"Function bypassed by setting {test['param']} to {test['value']}",
                    "payload": f"{test['param']}={test['value']}"
                })
    
    def test_excessive_permissions(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        restricted_functions = [
            "/delete",
            "/remove",
            "/admin",
            "/config",
            "/settings",
            "/manage",
            "/edit",
            "/create",
            "/add"
        ]
        
        for function in restricted_functions:
            if function not in url.lower():
                test_url = url + function
                response = self.send_request(test_url, method)
                
                if response and response.status_code == 200:
                    self.vulnerabilities.append({
                        "type": "Excessive Permissions",
                        "url": test_url,
                        "description": f"Access to restricted function {function}",
                        "payload": f"URL manipulation to access {function}"
                    })
    
    def test_transaction_abuse(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        if "checkout" not in url.lower() and "payment" not in url.lower() and "order" not in url.lower():
            return
        
        bypass_tests = [
            {"param": "amount", "value": "0.01"},
            {"param": "payment_method", "value": "bypass"},
            {"param": "status", "value": "completed"},
            {"param": "verified", "value": "true"},
            {"param": "paid", "value": "true"}
        ]
        
        for test in bypass_tests:
            if method.upper() == "GET":
                test_url = f"{url}?{test['param']}={test['value']}"
                response = self.send_request(test_url, method)
            else:
                data = {test['param']: test['value']}
                response = self.send_request(url, method, data=data)
            
            if response and ("success" in response.text.lower() or "completed" in response.text.lower()):
                self.vulnerabilities.append({
                    "type": "Transaction Abuse",
                    "url": url,
                    "description": f"Transaction abused by setting {test['param']} to {test['value']}",
                    "payload": f"{test['param']}={test['value']}"
                })
    
    def test_process_flaws(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD")
        
        multi_step_tests = [
            {"step": 1, "action": "skip"},
            {"step": 2, "action": "skip"},
            {"step": 3, "action": "skip"},
            {"step": 4, "action": "skip"},
            {"step": 5, "action": "skip"}
        ]
        
        for test in multi_step_tests:
            test_url = f"{url}?step={test['step'] + 1}"
            response = self.send_request(test_url, method)
            
            if response and response.status_code == 200:
                self.vulnerabilities.append({
                    "type": "Process Flaw",
                    "url": test_url,
                    "description": f"Process step {test['step']} can be skipped",
                    "payload": f"step={test['step'] + 1}"
                })
    
    def run(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        delay = int(self.get_option("DELAY"))
        
        if self.get_option("CRAWL").lower() == "true":
            self.crawl_url(url)
        
        for test in self.business_logic_tests:
            if delay > 0:
                time.sleep(delay)
            test["test"]()
        
        if self.vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(self.vulnerabilities)} business logic vulnerabilities",
                "vulnerabilities": self.vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No business logic vulnerabilities found"
            }
