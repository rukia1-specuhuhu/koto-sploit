import requests
import json
import re
import random
import string
from bs4 import BeautifulSoup

class WeakPasswordPolicyScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "USERNAME_PARAM": "username",
            "PASSWORD_PARAM": "password",
            "METHOD": "POST",
            "TIMEOUT": "10",
            "DELAY": "1",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "TEST_ACCOUNTS": "10",
            "VERIFY_URL": "",
            "SUCCESS_INDICATOR": "",
            "FAILURE_INDICATOR": "",
            "CSRF_TOKEN": "",
            "CSRF_PARAM": "",
            "BRUTE_FORCE": True,
            "COMMON_PASSWORDS": True,
            "POLICY_CHECK": True,
            "PASSWORD_COMPLEXITY": True,
            "PASSWORD_RECOVERY": True,
            "ACCOUNT_LOCKOUT": True
        }
        
        self.common_passwords = [
            "123456", "password", "12345678", "qwerty", "123456789",
            "12345", "1234", "111111", "1234567", "dragon",
            "1234567890", "michael", "654321", "pussy", "superman",
            "1qaz2wsx", "7777777", "fuckyou", "121212", "00000000",
            "qazwsx", "123qwe", "killer", "trustno1", "jordan",
            "jennifer", "696969", "welcome", "admin", "login"
        ]
        
        self.common_usernames = [
            "admin", "administrator", "root", "user", "test",
            "guest", "info", "demo", "manager", "support",
            "service", "operator", "super", "superuser", "supervisor",
            "account", "user1", "user2", "test1", "test2"
        ]
        
        self.password_patterns = {
            "length": {
                "short": {"min": 1, "max": 6},
                "medium": {"min": 7, "max": 10},
                "long": {"min": 11, "max": 20}
            },
            "complexity": {
                "lowercase": re.compile(r'[a-z]'),
                "uppercase": re.compile(r'[A-Z]'),
                "digits": re.compile(r'[0-9]'),
                "special": re.compile(r'[^a-zA-Z0-9]')
            },
            "common_patterns": [
                re.compile(r'(.)\1{2,}'),  # Repeated characters
                re.compile(r'123|234|345|456|567|678|789'),  # Sequential numbers
                re.compile(r'abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz', re.IGNORECASE),  # Sequential letters
                re.compile(r'qwerty|asdf|zxcv', re.IGNORECASE)  # Keyboard patterns
            ]
        }
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_password(self, length=8, complexity=0):
        if complexity == 0:  # Only lowercase
            chars = string.ascii_lowercase
        elif complexity == 1:  # Lowercase + digits
            chars = string.ascii_lowercase + string.digits
        elif complexity == 2:  # Lowercase + uppercase + digits
            chars = string.ascii_lowercase + string.ascii_uppercase + string.digits
        else:  # All characters
            chars = string.ascii_lowercase + string.ascii_uppercase + string.digits + string.punctuation
        
        return ''.join(random.choice(chars) for _ in range(length))
    
    def check_password_policy(self, password):
        results = {
            "length": len(password),
            "has_lowercase": bool(self.password_patterns["complexity"]["lowercase"].search(password)),
            "has_uppercase": bool(self.password_patterns["complexity"]["uppercase"].search(password)),
            "has_digits": bool(self.password_patterns["complexity"]["digits"].search(password)),
            "has_special": bool(self.password_patterns["complexity"]["special"].search(password)),
            "has_repeated_chars": bool(self.password_patterns["common_patterns"][0].search(password)),
            "has_sequential_nums": bool(self.password_patterns["common_patterns"][1].search(password)),
            "has_sequential_letters": bool(self.password_patterns["common_patterns"][2].search(password)),
            "has_keyboard_patterns": bool(self.password_patterns["common_patterns"][3].search(password))
        }
        
        score = 0
        if results["length"] >= 8:
            score += 1
        if results["has_lowercase"]:
            score += 1
        if results["has_uppercase"]:
            score += 1
        if results["has_digits"]:
            score += 1
        if results["has_special"]:
            score += 1
        if not results["has_repeated_chars"]:
            score += 1
        if not results["has_sequential_nums"]:
            score += 1
        if not results["has_sequential_letters"]:
            score += 1
        if not results["has_keyboard_patterns"]:
            score += 1
        
        results["score"] = score
        results["weak"] = score < 5
        
        return results
    
    def get_csrf_token(self, url, headers, cookies):
        try:
            response = requests.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False, headers=headers, cookies=cookies)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            csrf_token = None
            csrf_param = self.get_option("CSRF_PARAM")
            
            if csrf_param:
                csrf_input = soup.find('input', {'name': csrf_param})
                if csrf_input and csrf_input.get('value'):
                    csrf_token = csrf_input.get('value')
            
            if not csrf_token:
                for meta in soup.find_all('meta'):
                    if meta.get('name') == 'csrf-token':
                        csrf_token = meta.get('content')
                        break
            
            return csrf_token
        except:
            return None
    
    def test_login(self, username, password, headers, cookies):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        username_param = self.get_option("USERNAME_PARAM")
        password_param = self.get_option("PASSWORD_PARAM")
        timeout = int(self.get_option("TIMEOUT"))
        
        data = {
            username_param: username,
            password_param: password
        }
        
        if self.get_option("CSRF_TOKEN"):
            csrf_token = self.get_csrf_token(url, headers, cookies)
            if csrf_token:
                data[self.get_option("CSRF_PARAM")] = csrf_token
        
        try:
            if method == "GET":
                response = requests.get(url, params=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            else:
                response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            
            success_indicator = self.get_option("SUCCESS_INDICATOR")
            failure_indicator = self.get_option("FAILURE_INDICATOR")
            
            if success_indicator and success_indicator.lower() in response.text.lower():
                return True, "Login successful"
            
            if failure_indicator and failure_indicator.lower() in response.text.lower():
                return False, "Login failed"
            
            if self.get_option("VERIFY_URL"):
                verify_url = self.get_option("VERIFY_URL")
                verify_response = requests.get(verify_url, timeout=timeout, verify=False, headers=headers, cookies=response.cookies)
                
                if success_indicator and success_indicator.lower() in verify_response.text.lower():
                    return True, "Login successful (verified)"
            
            if len(response.text) < 1000:
                return False, "Login failed (short response)"
            
            if response.status_code == 200:
                return True, "Login successful (200 OK)"
            
            return False, "Login failed"
        
        except Exception as e:
            return False, f"Error: {str(e)}"
    
    def test_password_recovery(self, headers, cookies):
        try:
            response = requests.get(self.get_option("URL"), timeout=int(self.get_option("TIMEOUT")), verify=False, headers=headers, cookies=cookies)
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            recovery_links = []
            for link in soup.find_all('a'):
                href = link.get('href', '').lower()
                text = link.get_text().lower()
                
                if any(keyword in href or keyword in text for keyword in ['forgot', 'recover', 'reset', 'password']):
                    recovery_links.append(link.get('href'))
            
            if recovery_links:
                return True, f"Found {len(recovery_links)} password recovery links"
            
            return False, "No password recovery links found"
        
        except Exception as e:
            return False, f"Error checking password recovery: {str(e)}"
    
    def test_account_lockout(self, headers, cookies):
        username = self.common_usernames[0]
        weak_passwords = ["wrongpass1", "wrongpass2", "wrongpass3", "wrongpass4", "wrongpass5"]
        
        lockout_detected = False
        lockout_message = ""
        
        for i, password in enumerate(weak_passwords):
            success, message = self.test_login(username, password, headers, cookies)
            
            if i >= 3 and "locked" in message.lower() or "blocked" in message.lower() or "disabled" in message.lower():
                lockout_detected = True
                lockout_message = message
                break
        
        if lockout_detected:
            return True, f"Account lockout detected: {lockout_message}"
        
        return False, "No account lockout detected"
    
    def run(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        cookies = {}
        vulnerabilities = []
        
        if self.get_option("POLICY_CHECK"):
            test_passwords = [
                "a",  # Very short
                "12345",  # Short, only numbers
                "password",  # Common word
                "Password1",  # Common pattern
                "P@ssword123",  # Complex
                self.generate_password(12, 3)  # Strong
            ]
            
            for password in test_passwords:
                policy_result = self.check_password_policy(password)
                if policy_result["weak"]:
                    vulnerabilities.append({
                        "type": "Weak Password Policy",
                        "description": f"Weak password accepted: {password}",
                        "details": policy_result
                    })
        
        if self.get_option("PASSWORD_RECOVERY"):
            success, message = self.test_password_recovery(headers, cookies)
            if success:
                vulnerabilities.append({
                    "type": "Password Recovery",
                    "description": message
                })
        
        if self.get_option("ACCOUNT_LOCKOUT"):
            success, message = self.test_account_lockout(headers, cookies)
            if not success:
                vulnerabilities.append({
                    "type": "Account Lockout",
                    "description": message
                })
        
        if self.get_option("BRUTE_FORCE"):
            test_accounts = int(self.get_option("TEST_ACCOUNTS"))
            test_usernames = self.common_usernames[:min(test_accounts, len(self.common_usernames))]
            
            for username in test_usernames:
                if delay > 0:
                    time.sleep(delay)
                
                if self.get_option("COMMON_PASSWORDS"):
                    for password in self.common_passwords[:5]:  # Test top 5 common passwords
                        success, message = self.test_login(username, password, headers, cookies)
                        if success:
                            vulnerabilities.append({
                                "type": "Weak Credentials",
                                "description": f"Successful login with username: {username}, password: {password}"
                            })
                            break
                
                if not vulnerabilities or not any(v["type"] == "Weak Credentials" for v in vulnerabilities):
                    simple_passwords = [
                        username,
                        username + "123",
                        "123" + username,
                        username + "1",
                        username + "2023"
                    ]
                    
                    for password in simple_passwords:
                        success, message = self.test_login(username, password, headers, cookies)
                        if success:
                            vulnerabilities.append({
                                "type": "Weak Credentials",
                                "description": f"Successful login with username: {username}, password: {password}"
                            })
                            break
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} password policy issues",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No password policy issues found"
            }
