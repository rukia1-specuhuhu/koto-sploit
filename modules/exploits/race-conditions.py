import requests
import threading
import time
import random
import urllib.parse
from concurrent.futures import ThreadPoolExecutor

class RaceConditionScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "PARAM": "",
            "METHOD": "GET",
            "THREADS": "10",
            "REQUESTS": "50",
            "DELAY": "0",
            "TIMEOUT": "10",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "PAYLOAD": "",
            "RANDOM_PARAM": "False",
            "FOLLOW_REDIRECTS": "False"
        }
        
        self.indicators = [
            "HTTP 200",
            "HTTP 201",
            "HTTP 302",
            "success",
            "created",
            "added",
            "completed",
            "confirmed",
            "verified",
            "accepted",
            "updated",
            "deleted",
            "removed"
        ]
        
        self.responses = []
        self.lock = threading.Lock()
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_value(self):
        return ''.join(random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(8))
    
    def make_request(self, url, param, payload, method, headers, cookies, timeout):
        try:
            if method == "GET":
                if param:
                    test_url = f"{url}?{param}={urllib.parse.quote(payload)}"
                    response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies, 
                                          allow_redirects=self.get_option("FOLLOW_REDIRECTS").lower() == "true")
                else:
                    response = requests.get(url, timeout=timeout, verify=False, headers=headers, cookies=cookies,
                                          allow_redirects=self.get_option("FOLLOW_REDIRECTS").lower() == "true")
            else:
                if param:
                    data = {param: payload}
                    response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies,
                                          allow_redirects=self.get_option("FOLLOW_REDIRECTS").lower() == "true")
                else:
                    response = requests.post(url, timeout=timeout, verify=False, headers=headers, cookies=cookies,
                                          allow_redirects=self.get_option("FOLLOW_REDIRECTS").lower() == "true")
            
            with self.lock:
                self.responses.append({
                    "status_code": response.status_code,
                    "content": response.text,
                    "headers": dict(response.headers),
                    "payload": payload
                })
            
            return response
        except Exception as e:
            with self.lock:
                self.responses.append({
                    "error": str(e),
                    "payload": payload
                })
            return None
    
    def analyze_responses(self):
        status_codes = {}
        content_lengths = {}
        unique_responses = set()
        
        for response in self.responses:
            if "error" in response:
                continue
                
            status_code = response["status_code"]
            content_length = len(response["content"])
            
            if status_code not in status_codes:
                status_codes[status_code] = 0
            status_codes[status_code] += 1
            
            if content_length not in content_lengths:
                content_lengths[content_length] = 0
            content_lengths[content_length] += 1
            
            unique_responses.add(response["content"])
        
        vulnerabilities = []
        
        if len(status_codes) > 1:
            vulnerabilities.append({
                "type": "Status Code Variation",
                "details": f"Multiple status codes detected: {status_codes}"
            })
        
        if len(content_lengths) > 1:
            vulnerabilities.append({
                "type": "Response Length Variation",
                "details": f"Multiple response lengths detected: {list(content_lengths.keys())[:5]}"
            })
        
        if len(unique_responses) > 1:
            vulnerabilities.append({
                "type": "Content Variation",
                "details": f"Multiple different responses detected"
            })
        
        for response in self.responses:
            if "error" in response:
                continue
                
            for indicator in self.indicators:
                if indicator.lower() in response["content"].lower():
                    vulnerabilities.append({
                        "type": "Success Indicator",
                        "details": f"Found success indicator '{indicator}' in response"
                    })
                    break
        
        return vulnerabilities
    
    def run(self):
        url = self.get_option("URL")
        param = self.get_option("PARAM")
        method = self.get_option("METHOD").upper()
        threads = int(self.get_option("THREADS"))
        requests_count = int(self.get_option("REQUESTS"))
        delay = float(self.get_option("DELAY"))
        timeout = int(self.get_option("TIMEOUT"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        self.responses = []
        
        def worker():
            payload = self.get_option("PAYLOAD")
            
            if self.get_option("RANDOM_PARAM").lower() == "true":
                payload = self.generate_random_value()
            
            if delay > 0:
                time.sleep(delay)
            
            self.make_request(url, param, payload, method, headers, cookies={}, timeout=timeout)
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            for _ in range(requests_count):
                executor.submit(worker)
        
        vulnerabilities = self.analyze_responses()
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} potential race condition vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No race condition vulnerabilities detected"
            }
