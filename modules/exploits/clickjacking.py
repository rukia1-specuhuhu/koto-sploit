import requests
import urllib.parse
from bs4 import BeautifulSoup
import re

class ClickjackingScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "TIMEOUT": "10",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "FOLLOW_REDIRECTS": True,
            "CHECK_IFRAME": True,
            "CHECK_XFO": True,
            "CHECK_CSP": True,
            "CHECK_UI_REDRESS": True
        }
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def run(self):
        url = self.get_option("URL")
        timeout = int(self.get_option("TIMEOUT"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        vulnerabilities = []
        
        try:
            response = requests.get(
                url, 
                timeout=timeout, 
                verify=False, 
                headers=headers,
                allow_redirects=self.get_option("FOLLOW_REDIRECTS")
            )
            
            if self.get_option("CHECK_IFRAME"):
                iframe_vuln = self.check_iframe_embedding(response, url)
                if iframe_vuln:
                    vulnerabilities.append(iframe_vuln)
            
            if self.get_option("CHECK_XFO"):
                xfo_vuln = self.check_x_frame_options(response)
                if xfo_vuln:
                    vulnerabilities.append(xfo_vuln)
            
            if self.get_option("CHECK_CSP"):
                csp_vuln = self.check_content_security_policy(response)
                if csp_vuln:
                    vulnerabilities.append(csp_vuln)
            
            if self.get_option("CHECK_UI_REDRESS"):
                ui_vuln = self.check_ui_redress(response)
                if ui_vuln:
                    vulnerabilities.append(ui_vuln)
            
            if vulnerabilities:
                return {
                    "success": True,
                    "message": f"Found {len(vulnerabilities)} clickjacking vulnerabilities",
                    "vulnerabilities": vulnerabilities
                }
            else:
                return {
                    "success": True,
                    "message": "No clickjacking vulnerabilities found"
                }
                
        except Exception as e:
            return {
                "success": False,
                "message": f"Error scanning: {str(e)}"
            }
    
    def check_iframe_embedding(self, response, url):
        try:
            test_headers = {
                "User-Agent": self.get_option("USER_AGENT"),
                "Referer": "https://evil.com/clickjack.html"
            }
            
            test_response = requests.get(
                url,
                timeout=int(self.get_option("TIMEOUT")),
                verify=False,
                headers=test_headers,
                allow_redirects=False
            )
            
            if test_response.status_code == 200:
                return {
                    "type": "Iframe Embedding",
                    "description": "The page can be embedded in an iframe without restrictions",
                    "severity": "Medium",
                    "proof": f"Page loaded successfully with iframe embedding test"
                }
        except:
            pass
        
        return None
    
    def check_x_frame_options(self, response):
        xfo_header = response.headers.get('X-Frame-Options', '').lower()
        
        if not xfo_header:
            return {
                "type": "Missing X-Frame-Options",
                "description": "X-Frame-Options header is not set",
                "severity": "Medium",
                "proof": "Response does not include X-Frame-Options header"
            }
        
        if xfo_header not in ['deny', 'sameorigin']:
            return {
                "type": "Weak X-Frame-Options",
                "description": f"X-Frame-Options is set to '{xfo_header}' which is not secure",
                "severity": "Medium",
                "proof": f"X-Frame-Options: {response.headers.get('X-Frame-Options')}"
            }
        
        return None
    
    def check_content_security_policy(self, response):
        csp_header = response.headers.get('Content-Security-Policy', '').lower()
        
        if not csp_header:
            return {
                "type": "Missing Content-Security-Policy",
                "description": "Content-Security-Policy header is not set",
                "severity": "Medium",
                "proof": "Response does not include Content-Security-Policy header"
            }
        
        frame_ancestors = re.search(r'frame-ancestors\s+([^;]+)', csp_header)
        
        if not frame_ancestors:
            return {
                "type": "Missing frame-ancestors in CSP",
                "description": "Content-Security-Policy does not include frame-ancestors directive",
                "severity": "Medium",
                "proof": f"Content-Security-Policy: {csp_header}"
            }
        
        frame_directives = frame_ancestors.group(1).strip()
        
        if 'none' not in frame_directives and "'self'" not in frame_directives:
            return {
                "type": "Weak frame-ancestors in CSP",
                "description": f"frame-ancestors directive allows embedding from external sources: {frame_directives}",
                "severity": "Medium",
                "proof": f"frame-ancestors: {frame_directives}"
            }
        
        return None
    
    def check_ui_redress(self, response):
        soup = BeautifulSoup(response.text, 'html.parser')
        
        vulnerable_elements = []
        
        for tag in soup.find_all(['iframe', 'frame']):
            vulnerable_elements.append(f"{tag.name} element found")
        
        for tag in soup.find_all(True):
            if tag.has_attr('style') and 'position' in tag.get('style', '').lower():
                vulnerable_elements.append(f"Element with positioning style found: {tag.name}")
        
        if vulnerable_elements:
            return {
                "type": "Potential UI Redressing",
                "description": "Page contains elements that could be used in clickjacking attacks",
                "severity": "Low",
                "proof": "; ".join(vulnerable_elements[:5])
            }
        
        return None
