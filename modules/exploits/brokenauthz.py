import requests
import json
import random
import string
import urllib.parse
from bs4 import BeautifulSoup

class BrokenAuthzScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "METHOD": "GET",
            "TIMEOUT": "10",
            "DELAY": "0",
            "COOKIE": "",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "AUTH_TOKEN": "",
            "AUTH_HEADER": "Authorization",
            "AUTH_TYPE": "Bearer",
            "DEPTH": "2",
            "COMMON_ENDPOINTS": "true",
            "TEST_ADMIN_ENDPOINTS": "true",
            "TEST_IDOR": "true",
            "TEST_METHODS": "true",
            "FOLLOW_REDIRECTS": "false"
        }
        
        self.admin_endpoints = [
            "/admin",
            "/admin/dashboard",
            "/admin/users",
            "/admin/settings",
            "/admin/config",
            "/admin/logs",
            "/admin/backup",
            "/admin/create",
            "/admin/delete",
            "/admin/edit",
            "/admin/add",
            "/admin/manage",
            "/administrator",
            "/adm",
            "/wp-admin",
            "/phpmyadmin",
            "/myadmin",
            "/admincp",
            "/administer",
            "/sysadmin",
            "/admin_area",
            "/admin-login",
            "/controlpanel",
            "/cpanel",
            "/panel",
            "/manager",
            "/root",
            "/administration",
            "/superuser",
            "/supervisor"
        ]
        
        self.sensitive_endpoints = [
            "/api/users",
            "/api/users/all",
            "/api/admin",
            "/api/config",
            "/api/settings",
            "/api/logs",
            "/api/backups",
            "/api/secrets",
            "/api/internal",
            "/api/privileges",
            "/api/roles",
            "/api/permissions",
            "/api/admin/users",
            "/api/admin/settings",
            "/api/admin/logs",
            "/api/admin/config",
            "/users",
            "/users/all",
            "/settings",
            "/config",
            "/logs",
            "/backups",
            "/secrets",
            "/internal",
            "/privileges",
            "/roles",
            "/permissions",
            "/account",
            "/profile",
            "/user/profile",
            "/user/settings",
            "/user/account"
        ]
        
        self.idor_patterns = [
            "/user/{id}",
            "/profile/{id}",
            "/account/{id}",
            "/api/user/{id}",
            "/api/profile/{id}",
            "/api/account/{id}",
            "/users/{id}",
            "/member/{id}",
            "/customer/{id}",
            "/client/{id}",
            "/employee/{id}",
            "/staff/{id}",
            "/admin/user/{id}",
            "/admin/users/{id}",
            "/admin/profile/{id}",
            "/admin/account/{id}"
        ]
        
        self.http_methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
        
        self.status_indicators = {
            "unauthorized": [401, 403],
            "success": [200, 201, 202, 204],
            "redirect": [301, 302, 303, 307, 308],
            "error": [400, 404, 500, 501, 502, 503]
        }
        
        self.success_keywords = [
            "admin", "dashboard", "settings", "users", "logs", "config", "backup", 
            "manage", "control", "panel", "profile", "account", "privileges", 
            "roles", "permissions", "secret", "internal"
        ]
        
        self.error_keywords = [
            "unauthorized", "forbidden", "access denied", "permission denied", 
            "not allowed", "not permitted", "login required", "authentication required"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_string(self, length=8):
        return ''.join(random.choice(string.ascii_lowercase) for i in range(length))
    
    def generate_random_id(self):
        return random.randint(1, 1000)
    
    def prepare_headers(self):
        headers = {
            "User-Agent": self.get_option("USER_AGENT")
        }
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        if self.get_option("AUTH_TOKEN"):
            auth_header = self.get_option("AUTH_HEADER")
            auth_type = self.get_option("AUTH_TYPE")
            auth_token = self.get_option("AUTH_TOKEN")
            
            if auth_type.lower() == "bearer":
                headers[auth_header] = f"Bearer {auth_token}"
            elif auth_type.lower() == "basic":
                headers[auth_header] = f"Basic {auth_token}"
            else:
                headers[auth_header] = auth_token
        
        return headers
    
    def prepare_cookies(self):
        cookies = {}
        
        if self.get_option("COOKIE"):
            try:
                for cookie in self.get_option("COOKIE").split(";"):
                    if "=" in cookie:
                        key, value = cookie.split("=", 1)
                        cookies[key.strip()] = value.strip()
            except:
                pass
        
        return cookies
    
    def test_endpoint(self, url, method="GET", data=None, headers=None, cookies=None):
        try:
            timeout = int(self.get_option("TIMEOUT"))
            follow_redirects = self.get_option("FOLLOW_REDIRECTS").lower() == "true"
            
            if method.upper() == "GET":
                response = requests.get(
                    url, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            elif method.upper() == "POST":
                response = requests.post(
                    url, 
                    data=data, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            elif method.upper() == "PUT":
                response = requests.put(
                    url, 
                    data=data, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            elif method.upper() == "DELETE":
                response = requests.delete(
                    url, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            elif method.upper() == "PATCH":
                response = requests.patch(
                    url, 
                    data=data, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            elif method.upper() == "HEAD":
                response = requests.head(
                    url, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            elif method.upper() == "OPTIONS":
                response = requests.options(
                    url, 
                    timeout=timeout, 
                    verify=False, 
                    headers=headers, 
                    cookies=cookies,
                    allow_redirects=follow_redirects
                )
            
            return response
        
        except Exception as e:
            return None
    
    def check_response_indicators(self, response):
        if response is None:
            return {"status": "error", "reason": "No response"}
        
        result = {
            "status_code": response.status_code,
            "status": "unknown",
            "reason": "",
            "indicators": []
        }
        
        if response.status_code in self.status_indicators["success"]:
            result["status"] = "success"
            result["reason"] = f"Success status code: {response.status_code}"
            
            for keyword in self.success_keywords:
                if keyword.lower() in response.text.lower():
                    result["indicators"].append(f"Found keyword: {keyword}")
            
            if len(response.text) > 100:
                result["indicators"].append("Large response size")
            
            if "application/json" in response.headers.get("Content-Type", "").lower():
                try:
                    json_data = response.json()
                    if isinstance(json_data, dict) and len(json_data) > 0:
                        result["indicators"].append("Valid JSON response with data")
                except:
                    pass
        
        elif response.status_code in self.status_indicators["unauthorized"]:
            result["status"] = "unauthorized"
            result["reason"] = f"Unauthorized status code: {response.status_code}"
            
            for keyword in self.error_keywords:
                if keyword.lower() in response.text.lower():
                    result["indicators"].append(f"Found error keyword: {keyword}")
        
        elif response.status_code in self.status_indicators["redirect"]:
            result["status"] = "redirect"
            result["reason"] = f"Redirect status code: {response.status_code}"
        
        elif response.status_code in self.status_indicators["error"]:
            result["status"] = "error"
            result["reason"] = f"Error status code: {response.status_code}"
        else:
            result["status"] = "unknown"
            result["reason"] = f"Unknown status code: {response.status_code}"
        
        return result
    
    def test_admin_endpoints(self, base_url, headers, cookies):
        vulnerabilities = []
        
        for endpoint in self.admin_endpoints:
            if not base_url.endswith("/") and not endpoint.startswith("/"):
                endpoint = "/" + endpoint
            elif base_url.endswith("/") and endpoint.startswith("/"):
                endpoint = endpoint[1:]
            
            url = base_url + endpoint
            
            response = self.test_endpoint(url, "GET", headers=headers, cookies=cookies)
            result = self.check_response_indicators(response)
            
            if result["status"] == "success":
                vulnerabilities.append({
                    "type": "Admin Endpoint Access",
                    "url": url,
                    "method": "GET",
                    "status_code": result["status_code"],
                    "reason": result["reason"],
                    "indicators": result["indicators"]
                })
        
        return vulnerabilities
    
    def test_sensitive_endpoints(self, base_url, headers, cookies):
        vulnerabilities = []
        
        for endpoint in self.sensitive_endpoints:
            if not base_url.endswith("/") and not endpoint.startswith("/"):
                endpoint = "/" + endpoint
            elif base_url.endswith("/") and endpoint.startswith("/"):
                endpoint = endpoint[1:]
            
            url = base_url + endpoint
            
            response = self.test_endpoint(url, "GET", headers=headers, cookies=cookies)
            result = self.check_response_indicators(response)
            
            if result["status"] == "success":
                vulnerabilities.append({
                    "type": "Sensitive Endpoint Access",
                    "url": url,
                    "method": "GET",
                    "status_code": result["status_code"],
                    "reason": result["reason"],
                    "indicators": result["indicators"]
                })
        
        return vulnerabilities
    
    def test_idor(self, base_url, headers, cookies):
        vulnerabilities = []
        
        for pattern in self.idor_patterns:
            test_id = self.generate_random_id()
            endpoint = pattern.replace("{id}", str(test_id))
            
            if not base_url.endswith("/") and not endpoint.startswith("/"):
                endpoint = "/" + endpoint
            elif base_url.endswith("/") and endpoint.startswith("/"):
                endpoint = endpoint[1:]
            
            url = base_url + endpoint
            
            response = self.test_endpoint(url, "GET", headers=headers, cookies=cookies)
            result = self.check_response_indicators(response)
            
            if result["status"] == "success":
                vulnerabilities.append({
                    "type": "Insecure Direct Object Reference",
                    "url": url,
                    "method": "GET",
                    "status_code": result["status_code"],
                    "reason": result["reason"],
                    "indicators": result["indicators"]
                })
        
        return vulnerabilities
    
    def test_http_methods(self, base_url, headers, cookies):
        vulnerabilities = []
        
        if self.get_option("TEST_METHODS").lower() != "true":
            return vulnerabilities
        
        test_url = base_url
        
        for method in self.http_methods:
            response = self.test_endpoint(test_url, method, headers=headers, cookies=cookies)
            result = self.check_response_indicators(response)
            
            if result["status"] == "success" and method.upper() != "GET":
                vulnerabilities.append({
                    "type": "HTTP Method Access",
                    "url": test_url,
                    "method": method,
                    "status_code": result["status_code"],
                    "reason": result["reason"],
                    "indicators": result["indicators"]
                })
        
        return vulnerabilities
    
    def discover_endpoints(self, base_url, headers, cookies):
        endpoints = []
        
        try:
            response = self.test_endpoint(base_url, "GET", headers=headers, cookies=cookies)
            
            if response and response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                
                for link in soup.find_all('a'):
                    href = link.get('href')
                    if href and not href.startswith('#') and not href.startswith('javascript'):
                        if href.startswith('/'):
                            endpoints.append(href)
                        elif base_url in href:
                            endpoints.append(href.replace(base_url, ''))
                
                for script in soup.find_all('script'):
                    src = script.get('src')
                    if src and not src.startswith('#') and not src.startswith('javascript'):
                        if src.startswith('/'):
                            endpoints.append(src)
                        elif base_url in src:
                            endpoints.append(src.replace(base_url, ''))
                
                for form in soup.find_all('form'):
                    action = form.get('action')
                    if action and not action.startswith('#') and not action.startswith('javascript'):
                        if action.startswith('/'):
                            endpoints.append(action)
                        elif base_url in action:
                            endpoints.append(action.replace(base_url, ''))
        
        except:
            pass
        
        return endpoints
    
    def test_discovered_endpoints(self, base_url, endpoints, headers, cookies):
        vulnerabilities = []
        
        for endpoint in endpoints:
            if not base_url.endswith("/") and not endpoint.startswith("/"):
                endpoint = "/" + endpoint
            elif base_url.endswith("/") and endpoint.startswith("/"):
                endpoint = endpoint[1:]
            
            url = base_url + endpoint
            
            response = self.test_endpoint(url, "GET", headers=headers, cookies=cookies)
            result = self.check_response_indicators(response)
            
            if result["status"] == "success":
                vulnerabilities.append({
                    "type": "Discovered Endpoint Access",
                    "url": url,
                    "method": "GET",
                    "status_code": result["status_code"],
                    "reason": result["reason"],
                    "indicators": result["indicators"]
                })
        
        return vulnerabilities
    
    def run(self):
        url = self.get_option("URL")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = self.prepare_headers()
        cookies = self.prepare_cookies()
        
        vulnerabilities = []
        
        if self.get_option("TEST_ADMIN_ENDPOINTS").lower() == "true":
            admin_vulns = self.test_admin_endpoints(url, headers, cookies)
            vulnerabilities.extend(admin_vulns)
        
        if self.get_option("COMMON_ENDPOINTS").lower() == "true":
            sensitive_vulns = self.test_sensitive_endpoints(url, headers, cookies)
            vulnerabilities.extend(sensitive_vulns)
        
        if self.get_option("TEST_IDOR").lower() == "true":
            idor_vulns = self.test_idor(url, headers, cookies)
            vulnerabilities.extend(idor_vulns)
        
        method_vulns = self.test_http_methods(url, headers, cookies)
        vulnerabilities.extend(method_vulns)
        
        discovered_endpoints = self.discover_endpoints(url, headers, cookies)
        if discovered_endpoints:
            discovered_vulns = self.test_discovered_endpoints(url, discovered_endpoints, headers, cookies)
            vulnerabilities.extend(discovered_vulns)
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} potential authorization vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No authorization vulnerabilities detected"
            }
