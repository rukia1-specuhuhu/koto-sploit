import requests
import json
import random
import string
import time
import re
import base64
import hashlib
from urllib.parse import urlparse

class MobileAPIScanner:
    def __init__(self):
        self.options = {
            "TARGET_URL": "",
            "API_KEY": "",
            "AUTH_TOKEN": "",
            "METHOD": "GET",
            "HEADERS": "",
            "TIMEOUT": "10",
            "DELAY": "0",
            "VERIFY_SSL": False,
            "USER_AGENT": "Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36",
            "DEEP_SCAN": True,
            "TEST_IDOR": True,
            "TEST_BOLA": True,
            "TEST_BFLA": True,
            "TEST_AUTH_BYPASS": True,
            "TEST_RATE_LIMIT": True,
            "TEST_DATA_EXPOSURE": True,
            "TEST_INSECURE_COMM": True,
            "TEST_ENCRYPTION": True
        }
        
        self.idor_payloads = [
            {"id": 1},
            {"id": 2},
            {"id": 3},
            {"id": 4},
            {"id": 5},
            {"user_id": 1},
            {"user_id": 2},
            {"user_id": 3},
            {"user_id": 4},
            {"user_id": 5},
            {"account_id": 1},
            {"account_id": 2},
            {"account_id": 3},
            {"account_id": 4},
            {"account_id": 5},
            {"uuid": "00000000-0000-0000-0000-000000000001"},
            {"uuid": "00000000-0000-0000-0000-000000000002"},
            {"uuid": "00000000-0000-0000-0000-000000000003"},
            {"uuid": "00000000-0000-0000-0000-000000000004"},
            {"uuid": "00000000-0000-0000-0000-000000000005"}
        ]
        
        self.bola_payloads = [
            {"object_id": 1},
            {"object_id": 2},
            {"object_id": 3},
            {"object_id": 4},
            {"object_id": 5},
            {"resource_id": 1},
            {"resource_id": 2},
            {"resource_id": 3},
            {"resource_id": 4},
            {"resource_id": 5},
            {"file_id": 1},
            {"file_id": 2},
            {"file_id": 3},
            {"file_id": 4},
            {"file_id": 5},
            {"doc_id": 1},
            {"doc_id": 2},
            {"doc_id": 3},
            {"doc_id": 4},
            {"doc_id": 5}
        ]
        
        self.bfla_payloads = [
            {"function": "admin_get_users"},
            {"function": "admin_delete_user"},
            {"function": "admin_update_settings"},
            {"function": "system_shutdown"},
            {"function": "system_restart"},
            {"action": "admin_access"},
            {"action": "system_config"},
            {"action": "user_management"},
            {"action": "delete_all"},
            {"action": "export_all"},
            {"endpoint": "/admin/users"},
            {"endpoint": "/admin/settings"},
            {"endpoint": "/system/config"},
            {"endpoint": "/system/logs"},
            {"endpoint": "/system/shutdown"}
        ]
        
        self.auth_bypass_payloads = [
            {"api_key": ""},
            {"api_key": "null"},
            {"api_key": "undefined"},
            {"api_key": "123456"},
            {"api_key": "admin"},
            {"token": ""},
            {"token": "null"},
            {"token": "undefined"},
            {"token": "123456"},
            {"token": "admin"},
            {"auth_token": ""},
            {"auth_token": "null"},
            {"auth_token": "undefined"},
            {"auth_token": "123456"},
            {"auth_token": "admin"},
            {"authorization": ""},
            {"authorization": "null"},
            {"authorization": "undefined"},
            {"authorization": "123456"},
            {"authorization": "admin"}
        ]
        
        self.rate_limit_test_count = 50
        self.sensitive_data_patterns = [
            r"\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b",
            r"\b\d{3}-\d{2}-\d{4}\b",
            r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b",
            r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",
            r"\b(?:\d[ -]*?){13,16}\b",
            r"password\s*[:=]\s*[^\s]+",
            r"api_key\s*[:=]\s*[^\s]+",
            r"secret\s*[:=]\s*[^\s]+",
            r"token\s*[:=]\s*[^\s]+"
        ]
        
        self.insecure_comm_patterns = [
            "http://",
            "ws://",
            "ftp://",
            "telnet://"
        ]
        
        self.weak_encryption_patterns = [
            "md5",
            "sha1",
            "des",
            "rc4",
            "base64"
        ]
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_string(self, length=10):
        return ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(length))
    
    def generate_random_email(self):
        return self.generate_random_string(8) + "@" + self.generate_random_string(5) + ".com"
    
    def generate_random_phone(self):
        return ''.join(random.choice(string.digits) for _ in range(10))
    
    def run(self):
        target_url = self.get_option("TARGET_URL")
        method = self.get_option("METHOD").upper()
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        headers = {
            "User-Agent": self.get_option("USER_AGENT"),
            "Content-Type": "application/json"
        }
        
        if self.get_option("API_KEY"):
            headers["X-API-Key"] = self.get_option("API_KEY")
        
        if self.get_option("AUTH_TOKEN"):
            headers["Authorization"] = "Bearer " + self.get_option("AUTH_TOKEN")
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        headers[key.strip()] = value.strip()
            except:
                pass
        
        vulnerabilities = []
        
        if self.get_option("TEST_IDOR"):
            idor_results = self.test_idor(target_url, method, timeout, delay, headers)
            vulnerabilities.extend(idor_results)
        
        if self.get_option("TEST_BOLA"):
            bola_results = self.test_bola(target_url, method, timeout, delay, headers)
            vulnerabilities.extend(bola_results)
        
        if self.get_option("TEST_BFLA"):
            bfla_results = self.test_bfla(target_url, method, timeout, delay, headers)
            vulnerabilities.extend(bfla_results)
        
        if self.get_option("TEST_AUTH_BYPASS"):
            auth_results = self.test_auth_bypass(target_url, method, timeout, delay, headers)
            vulnerabilities.extend(auth_results)
        
        if self.get_option("TEST_RATE_LIMIT"):
            rate_results = self.test_rate_limit(target_url, method, timeout, headers)
            vulnerabilities.extend(rate_results)
        
        if self.get_option("TEST_DATA_EXPOSURE"):
            data_results = self.test_data_exposure(target_url, method, timeout, headers)
            vulnerabilities.extend(data_results)
        
        if self.get_option("TEST_INSECURE_COMM"):
            comm_results = self.test_insecure_comm(target_url, method, timeout, headers)
            vulnerabilities.extend(comm_results)
        
        if self.get_option("TEST_ENCRYPTION"):
            enc_results = self.test_encryption(target_url, method, timeout, headers)
            vulnerabilities.extend(enc_results)
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No vulnerabilities found"
            }
    
    def test_idor(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        for payload in self.idor_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                if method == "GET":
                    response = requests.get(url, params=payload, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                else:
                    response = requests.post(url, json=payload, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                
                if response.status_code == 200:
                    if "unauthorized" not in response.text.lower() and "forbidden" not in response.text.lower():
                        vulnerabilities.append({
                            "type": "Insecure Direct Object Reference (IDOR)",
                            "payload": payload,
                            "evidence": f"Accessed resource with ID {list(payload.values())[0]}"
                        })
            except:
                pass
        
        return vulnerabilities
    
    def test_bola(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        for payload in self.bola_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                if method == "GET":
                    response = requests.get(url, params=payload, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                else:
                    response = requests.post(url, json=payload, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                
                if response.status_code == 200:
                    if "unauthorized" not in response.text.lower() and "forbidden" not in response.text.lower():
                        vulnerabilities.append({
                            "type": "Broken Object Level Authorization (BOLA)",
                            "payload": payload,
                            "evidence": f"Accessed object with ID {list(payload.values())[0]}"
                        })
            except:
                pass
        
        return vulnerabilities
    
    def test_bfla(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        for payload in self.bfla_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                if method == "GET":
                    response = requests.get(url, params=payload, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                else:
                    response = requests.post(url, json=payload, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                
                if response.status_code == 200:
                    vulnerabilities.append({
                        "type": "Broken Function Level Authorization (BFLA)",
                        "payload": payload,
                        "evidence": f"Accessed privileged function: {list(payload.values())[0]}"
                    })
            except:
                pass
        
        return vulnerabilities
    
    def test_auth_bypass(self, url, method, timeout, delay, headers):
        vulnerabilities = []
        
        for payload in self.auth_bypass_payloads:
            if delay > 0:
                time.sleep(delay)
            
            try:
                test_headers = headers.copy()
                
                for key, value in payload.items():
                    test_headers[key] = value
                
                if method == "GET":
                    response = requests.get(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=test_headers)
                else:
                    response = requests.post(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=test_headers)
                
                if response.status_code == 200:
                    vulnerabilities.append({
                        "type": "Authentication Bypass",
                        "payload": payload,
                        "evidence": f"Bypassed authentication with {list(payload.keys())[0]}: {list(payload.values())[0]}"
                    })
            except:
                pass
        
        return vulnerabilities
    
    def test_rate_limit(self, url, method, timeout, headers):
        vulnerabilities = []
        
        success_count = 0
        
        for i in range(self.rate_limit_test_count):
            try:
                if method == "GET":
                    response = requests.get(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                else:
                    response = requests.post(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
                
                if response.status_code == 200:
                    success_count += 1
                elif response.status_code == 429:
                    break
            except:
                pass
        
        if success_count > 20:
            vulnerabilities.append({
                "type": "Missing Rate Limiting",
                "payload": f"Made {success_count} successful requests",
                "evidence": f"No rate limiting detected after {success_count} requests"
            })
        
        return vulnerabilities
    
    def test_data_exposure(self, url, method, timeout, headers):
        vulnerabilities = []
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
            else:
                response = requests.post(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
            
            response_text = response.text
            
            for pattern in self.sensitive_data_patterns:
                matches = re.findall(pattern, response_text)
                if matches:
                    vulnerabilities.append({
                        "type": "Sensitive Data Exposure",
                        "payload": pattern,
                        "evidence": f"Found sensitive data pattern: {matches[0]}"
                    })
        except:
            pass
        
        return vulnerabilities
    
    def test_insecure_comm(self, url, method, timeout, headers):
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        
        if parsed_url.scheme == "http":
            vulnerabilities.append({
                "type": "Insecure Communication",
                "payload": "HTTP instead of HTTPS",
                "evidence": f"URL uses HTTP: {url}"
            })
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
            else:
                response = requests.post(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
            
            response_text = response.text
            
            for pattern in self.insecure_comm_patterns:
                if pattern in response_text:
                    vulnerabilities.append({
                        "type": "Insecure Communication",
                        "payload": pattern,
                        "evidence": f"Found insecure communication pattern: {pattern}"
                    })
        except:
            pass
        
        return vulnerabilities
    
    def test_encryption(self, url, method, timeout, headers):
        vulnerabilities = []
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
            else:
                response = requests.post(url, timeout=timeout, verify=self.get_option("VERIFY_SSL"), headers=headers)
            
            response_text = response.text.lower()
            
            for pattern in self.weak_encryption_patterns:
                if pattern in response_text:
                    vulnerabilities.append({
                        "type": "Weak Encryption",
                        "payload": pattern,
                        "evidence": f"Found weak encryption pattern: {pattern}"
                    })
            
            if "base64" in response_text:
                base64_matches = re.findall(r'[A-Za-z0-9+/=]{20,}', response_text)
                if base64_matches:
                    vulnerabilities.append({
                        "type": "Potential Base64 Encoded Data",
                        "payload": "Base64 encoded data",
                        "evidence": f"Found potential base64 encoded data: {base64_matches[0][:50]}..."
                    })
        except:
            pass
        
        return vulnerabilities
