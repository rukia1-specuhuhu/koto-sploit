import requests
import random
import string
import json
import base64
import time
import urllib.parse
from bs4 import BeautifulSoup
from collections import OrderedDict

class BrokenAuthenticationScanner:
    def __init__(self):
        self.options = {
            "URL": "",
            "USERNAME_FIELD": "username",
            "PASSWORD_FIELD": "password",
            "SUBMIT_FIELD": "submit",
            "LOGIN_ENDPOINT": "/login",
            "LOGOUT_ENDPOINT": "/logout",
            "PROTECTED_ENDPOINT": "/dashboard",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "TIMEOUT": "10",
            "DELAY": "1",
            "HEADERS": "",
            "COOKIE": "",
            "VERIFY_SSL": False,
            "FOLLOW_REDIRECTS": True,
            "BRUTE_FORCE": True,
            "COMMON_CREDENTIALS": True,
            "WEAK_PASSWORD_POLICY": True,
            "SESSION_MANAGEMENT": True,
            "TOKEN_PREDICTABILITY": True,
            "AUTH_BYPASS": True,
            "RATE_LIMIT_TEST": True,
            "ACCOUNT_LOCKOUT_TEST": True,
            "PASSWORD_RESET_TEST": True,
            "OAUTH_MISCONFIG": True,
            "JWT_TEST": True
        }
        
        self.common_usernames = [
            "admin", "administrator", "root", "user", "test", "guest", "demo",
            "webmaster", "superuser", "supervisor", "manager", "support", "staff",
            "employee", "user1", "user2", "admin1", "admin2", "test1", "test2",
            "info", "contact", "service", "account", "login", "password", "qwerty",
            "oracle", "postgres", "mysql", "sa", "tomcat", "apache", "nginx"
        ]
        
        self.common_passwords = [
            "password", "123456", "12345678", "123456789", "12345", "1234567",
            "admin", "admin123", "root", "password1", "qwerty", "123123", "111111",
            "1234", "1234567890", "000000", "54321", "1q2w3e", "1qaz2wsx",
            "adminadmin", "welcome", "login", "pass", "test", "demo", "guest"
        ]
        
        self.common_credentials = [
            ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
            ("admin", "admin123"), ("root", "root"), ("root", "password"),
            ("admin", ""), ("", "admin"), ("user", "user"), ("guest", "guest"),
            ("test", "test"), ("demo", "demo"), ("admin", "qwerty"),
            ("administrator", "administrator"), ("administrator", "password"),
            ("admin", "letmein"), ("admin", "welcome"), ("admin", "12345678")
        ]
        
        self.weak_passwords = [
            "password", "123456", "12345678", "123456789", "12345", "1234567",
            "admin", "admin123", "root", "password1", "qwerty", "123123", "111111"
        ]
        
        self.session = requests.Session()
        self.session.verify = bool(self.get_option("VERIFY_SSL"))
        self.session.headers.update({"User-Agent": self.get_option("USER_AGENT")})
        
        if self.get_option("COOKIE"):
            self.session.headers.update({"Cookie": self.get_option("COOKIE")})
        
        if self.get_option("HEADERS"):
            try:
                for header in self.get_option("HEADERS").split("\\n"):
                    if ":" in header:
                        key, value = header.split(":", 1)
                        self.session.headers[key.strip()] = value.strip()
            except:
                pass
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def generate_random_string(self, length=8):
        return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))
    
    def generate_random_email(self):
        username = self.generate_random_string(8)
        domain = random.choice(["gmail.com", "yahoo.com", "hotmail.com", "example.com"])
        return f"{username}@{domain}"
    
    def extract_csrf_token(self, response):
        soup = BeautifulSoup(response.text, 'html.parser')
        csrf_token = None
        
        for input_tag in soup.find_all('input'):
            if input_tag.get('type') == 'hidden' and (
                'csrf' in input_tag.get('name', '').lower() or 
                'token' in input_tag.get('name', '').lower()
            ):
                csrf_token = input_tag.get('value')
                break
        
        if not csrf_token:
            for meta_tag in soup.find_all('meta'):
                if 'csrf' in meta_tag.get('name', '').lower() or 'token' in meta_tag.get('name', '').lower():
                    csrf_token = meta_tag.get('content')
                    break
        
        return csrf_token
    
    def test_brute_force(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        login_endpoint = self.get_option("LOGIN_ENDPOINT")
        username_field = self.get_option("USERNAME_FIELD")
        password_field = self.get_option("PASSWORD_FIELD")
        submit_field = self.get_option("SUBMIT_FIELD")
        timeout = int(self.get_option("TIMEOUT"))
        delay = int(self.get_option("DELAY"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        login_url = base_url + login_endpoint.lstrip('/')
        
        try:
            response = self.session.get(login_url, timeout=timeout)
            csrf_token = self.extract_csrf_token(response)
            
            if self.get_option("COMMON_CREDENTIALS"):
                for username, password in self.common_credentials:
                    if delay > 0:
                        time.sleep(delay)
                    
                    data = {
                        username_field: username,
                        password_field: password,
                        submit_field: "Login"
                    }
                    
                    if csrf_token:
                        data['csrf_token'] = csrf_token
                    
                    try:
                        response = self.session.post(
                            login_url,
                            data=data,
                            timeout=timeout,
                            allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                        )
                        
                        if "invalid" not in response.text.lower() and "error" not in response.text.lower():
                            if response.status_code == 200 and "dashboard" in response.url:
                                vulnerabilities.append({
                                    "type": "Weak Credentials",
                                    "username": username,
                                    "password": password,
                                    "description": f"Successful login with common credentials: {username}/{password}"
                                })
                                break
                    except:
                        pass
            
            if self.get_option("BRUTE_FORCE") and not vulnerabilities:
                test_username = self.common_usernames[0]
                
                for password in self.common_passwords[:10]:
                    if delay > 0:
                        time.sleep(delay)
                    
                    data = {
                        username_field: test_username,
                        password_field: password,
                        submit_field: "Login"
                    }
                    
                    if csrf_token:
                        data['csrf_token'] = csrf_token
                    
                    try:
                        response = self.session.post(
                            login_url,
                            data=data,
                            timeout=timeout,
                            allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                        )
                        
                        if "invalid" not in response.text.lower() and "error" not in response.text.lower():
                            if response.status_code == 200 and "dashboard" in response.url:
                                vulnerabilities.append({
                                    "type": "Brute Force Vulnerability",
                                    "username": test_username,
                                    "password": password,
                                    "description": f"Successful brute force attack: {test_username}/{password}"
                                })
                                break
                    except:
                        pass
        
        except:
            pass
        
        return vulnerabilities
    
    def test_weak_password_policy(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        register_endpoint = "/register"
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        register_url = base_url + register_endpoint.lstrip('/')
        
        try:
            response = self.session.get(register_url, timeout=timeout)
            
            if response.status_code == 200:
                for password in self.weak_passwords:
                    username = self.generate_random_string(8)
                    email = self.generate_random_email()
                    
                    data = {
                        "username": username,
                        "email": email,
                        "password": password,
                        "confirm_password": password,
                        "register": "Register"
                    }
                    
                    try:
                        response = self.session.post(
                            register_url,
                            data=data,
                            timeout=timeout,
                            allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                        )
                        
                        if "success" in response.text.lower() or "account created" in response.text.lower():
                            vulnerabilities.append({
                                "type": "Weak Password Policy",
                                "password": password,
                                "description": f"Account created with weak password: {password}"
                            })
                            break
                    except:
                        pass
        
        except:
            pass
        
        return vulnerabilities
    
    def test_session_management(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        protected_endpoint = self.get_option("PROTECTED_ENDPOINT")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        protected_url = base_url + protected_endpoint.lstrip('/')
        
        try:
            response = self.session.get(protected_url, timeout=timeout)
            
            if response.status_code == 200:
                session_id = self.session.cookies.get_dict().get('sessionid')
                
                if session_id:
                    self.session.cookies.clear()
                    
                    new_headers = self.session.headers.copy()
                    new_headers['Cookie'] = f"sessionid={session_id}"
                    
                    try:
                        response = requests.get(
                            protected_url,
                            headers=new_headers,
                            timeout=timeout,
                            verify=bool(self.get_option("VERIFY_SSL"))
                        )
                        
                        if response.status_code == 200:
                            vulnerabilities.append({
                                "type": "Session Management",
                                "session_id": session_id,
                                "description": "Session fixation vulnerability - session ID remains valid after logout"
                            })
                    except:
                        pass
        
        except:
            pass
        
        return vulnerabilities
    
    def test_token_predictability(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        login_endpoint = self.get_option("LOGIN_ENDPOINT")
        username_field = self.get_option("USERNAME_FIELD")
        password_field = self.get_option("PASSWORD_FIELD")
        submit_field = self.get_option("SUBMIT_FIELD")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        login_url = base_url + login_endpoint.lstrip('/')
        
        try:
            response = self.session.get(login_url, timeout=timeout)
            csrf_token = self.extract_csrf_token(response)
            
            tokens = []
            
            for i in range(3):
                data = {
                    username_field: self.generate_random_string(8),
                    password_field: self.generate_random_string(8),
                    submit_field: "Login"
                }
                
                if csrf_token:
                    data['csrf_token'] = csrf_token
                
                try:
                    response = self.session.post(
                        login_url,
                        data=data,
                        timeout=timeout,
                        allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                    )
                    
                    new_csrf_token = self.extract_csrf_token(response)
                    if new_csrf_token:
                        tokens.append(new_csrf_token)
                except:
                    pass
            
            if len(tokens) >= 2:
                if tokens[0] == tokens[1]:
                    vulnerabilities.append({
                        "type": "Token Predictability",
                        "token": tokens[0],
                        "description": "CSRF tokens are static and predictable"
                    })
        
        except:
            pass
        
        return vulnerabilities
    
    def test_auth_bypass(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        protected_endpoint = self.get_option("PROTECTED_ENDPOINT")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        protected_url = base_url + protected_endpoint.lstrip('/')
        
        bypass_techniques = [
            lambda url: url + "?admin=true",
            lambda url: url + "?debug=true",
            lambda url: url + "?test=1",
            lambda url: url.replace("https", "http"),
            lambda url: url + "?bypass=1",
            lambda url: url + "?noauth=1",
            lambda url: url + "?role=admin"
        ]
        
        for technique in bypass_techniques:
            try:
                bypass_url = technique(protected_url)
                response = requests.get(
                    bypass_url,
                    timeout=timeout,
                    verify=bool(self.get_option("VERIFY_SSL"))
                )
                
                if response.status_code == 200:
                    vulnerabilities.append({
                        "type": "Authentication Bypass",
                        "url": bypass_url,
                        "description": f"Authentication bypass via URL manipulation: {bypass_url}"
                    })
                    break
            except:
                pass
        
        return vulnerabilities
    
    def test_rate_limiting(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        login_endpoint = self.get_option("LOGIN_ENDPOINT")
        username_field = self.get_option("USERNAME_FIELD")
        password_field = self.get_option("PASSWORD_FIELD")
        submit_field = self.get_option("SUBMIT_FIELD")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        login_url = base_url + login_endpoint.lstrip('/')
        
        try:
            response = self.session.get(login_url, timeout=timeout)
            csrf_token = self.extract_csrf_token(response)
            
            login_attempts = []
            
            for i in range(10):
                data = {
                    username_field: self.generate_random_string(8),
                    password_field: self.generate_random_string(8),
                    submit_field: "Login"
                }
                
                if csrf_token:
                    data['csrf_token'] = csrf_token
                
                try:
                    start_time = time.time()
                    response = self.session.post(
                        login_url,
                        data=data,
                        timeout=timeout,
                        allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                    )
                    end_time = time.time()
                    
                    login_attempts.append({
                        "attempt": i + 1,
                        "status_code": response.status_code,
                        "response_time": end_time - start_time,
                        "response_length": len(response.text)
                    })
                except:
                    pass
            
            if len(login_attempts) >= 5:
                status_codes = [attempt["status_code"] for attempt in login_attempts]
                response_times = [attempt["response_time"] for attempt in login_attempts]
                
                if len(set(status_codes)) == 1 and status_codes[0] == 200:
                    if max(response_times) - min(response_times) < 0.5:
                        vulnerabilities.append({
                            "type": "Missing Rate Limiting",
                            "attempts": len(login_attempts),
                            "description": f"No rate limiting detected after {len(login_attempts)} login attempts"
                        })
        
        except:
            pass
        
        return vulnerabilities
    
    def test_account_lockout(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        login_endpoint = self.get_option("LOGIN_ENDPOINT")
        username_field = self.get_option("USERNAME_FIELD")
        password_field = self.get_option("PASSWORD_FIELD")
        submit_field = self.get_option("SUBMIT_FIELD")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        login_url = base_url + login_endpoint.lstrip('/')
        
        try:
            response = self.session.get(login_url, timeout=timeout)
            csrf_token = self.extract_csrf_token(response)
            
            test_username = self.generate_random_string(8)
            test_password = self.generate_random_string(8)
            
            for i in range(10):
                data = {
                    username_field: test_username,
                    password_field: test_password,
                    submit_field: "Login"
                }
                
                if csrf_token:
                    data['csrf_token'] = csrf_token
                
                try:
                    response = self.session.post(
                        login_url,
                        data=data,
                        timeout=timeout,
                        allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                    )
                    
                    if "locked" in response.text.lower() or "blocked" in response.text.lower():
                        break
                except:
                    pass
            
            data = {
                username_field: test_username,
                password_field: self.generate_random_string(8),
                submit_field: "Login"
            }
            
            if csrf_token:
                data['csrf_token'] = csrf_token
            
            try:
                response = self.session.post(
                    login_url,
                    data=data,
                    timeout=timeout,
                    allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                )
                
                if "locked" not in response.text.lower() and "blocked" not in response.text.lower():
                    vulnerabilities.append({
                        "type": "Missing Account Lockout",
                        "username": test_username,
                        "description": f"Account lockout not implemented for user: {test_username}"
                    })
            except:
                pass
        
        except:
            pass
        
        return vulnerabilities
    
    def test_password_reset(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        reset_endpoint = "/reset-password"
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        reset_url = base_url + reset_endpoint.lstrip('/')
        
        try:
            response = self.session.get(reset_url, timeout=timeout)
            
            if response.status_code == 200:
                test_email = self.generate_random_email()
                
                data = {
                    "email": test_email,
                    "submit": "Reset Password"
                }
                
                try:
                    response = self.session.post(
                        reset_url,
                        data=data,
                        timeout=timeout,
                        allow_redirects=bool(self.get_option("FOLLOW_REDIRECTS"))
                    )
                    
                    if "email sent" in response.text.lower() or "check your email" in response.text.lower():
                        vulnerabilities.append({
                            "type": "Insecure Password Reset",
                            "email": test_email,
                            "description": f"Password reset functionality allows enumeration: {test_email}"
                        })
                except:
                    pass
        
        except:
            pass
        
        return vulnerabilities
    
    def test_oauth_misconfig(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        oauth_endpoints = [
            "/oauth/authorize",
            "/oauth/token",
            "/oauth/userinfo",
            "/oauth/.well-known/openid_configuration"
        ]
        
        for endpoint in oauth_endpoints:
            oauth_url = base_url + endpoint.lstrip('/')
            
            try:
                response = requests.get(
                    oauth_url,
                    timeout=timeout,
                    verify=bool(self.get_option("VERIFY_SSL"))
                )
                
                if response.status_code == 200 and "error" not in response.text.lower():
                    vulnerabilities.append({
                        "type": "OAuth Misconfiguration",
                        "endpoint": endpoint,
                        "description": f"OAuth endpoint accessible without authentication: {endpoint}"
                    })
                    break
            except:
                pass
        
        return vulnerabilities
    
    def test_jwt(self):
        vulnerabilities = []
        base_url = self.get_option("URL")
        protected_endpoint = self.get_option("PROTECTED_ENDPOINT")
        timeout = int(self.get_option("TIMEOUT"))
        
        if not base_url.endswith('/'):
            base_url += '/'
        
        protected_url = base_url + protected_endpoint.lstrip('/')
        
        try:
            response = self.session.get(protected_url, timeout=timeout)
            
            auth_header = self.session.headers.get('Authorization', '')
            
            if auth_header.startswith('Bearer '):
                jwt_token = auth_header[7:]
                
                try:
                    parts = jwt_token.split('.')
                    
                    if len(parts) == 3:
                        header = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))
                        payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
                        
                        if 'alg' in header and header['alg'] == 'none':
                            vulnerabilities.append({
                                "type": "JWT Algorithm Confusion",
                                "algorithm": header['alg'],
                                "description": "JWT token uses 'none' algorithm which is insecure"
                            })
                        
                        if 'sub' in payload and 'admin' in payload['sub'].lower():
                            vulnerabilities.append({
                                "type": "JWT Privilege Escalation",
                                "subject": payload['sub'],
                                "description": f"JWT token contains admin privileges: {payload['sub']}"
                            })
                        
                        modified_token = parts[0] + '.' + parts[1] + '.'
                        
                        new_headers = self.session.headers.copy()
                        new_headers['Authorization'] = f'Bearer {modified_token}'
                        
                        try:
                            response = requests.get(
                                protected_url,
                                headers=new_headers,
                                timeout=timeout,
                                verify=bool(self.get_option("VERIFY_SSL"))
                            )
                            
                            if response.status_code == 200:
                                vulnerabilities.append({
                                    "type": "JWT Signature Bypass",
                                    "description": "JWT token accepted without signature verification"
                                })
                        except:
                            pass
                except:
                    pass
        
        except:
            pass
        
        return vulnerabilities
    
    def run(self):
        vulnerabilities = []
        
        if self.get_option("BRUTE_FORCE") or self.get_option("COMMON_CREDENTIALS"):
            brute_force_vulns = self.test_brute_force()
            vulnerabilities.extend(brute_force_vulns)
        
        if self.get_option("WEAK_PASSWORD_POLICY"):
            weak_policy_vulns = self.test_weak_password_policy()
            vulnerabilities.extend(weak_policy_vulns)
        
        if self.get_option("SESSION_MANAGEMENT"):
            session_vulns = self.test_session_management()
            vulnerabilities.extend(session_vulns)
        
        if self.get_option("TOKEN_PREDICTABILITY"):
            token_vulns = self.test_token_predictability()
            vulnerabilities.extend(token_vulns)
        
        if self.get_option("AUTH_BYPASS"):
            auth_bypass_vulns = self.test_auth_bypass()
            vulnerabilities.extend(auth_bypass_vulns)
        
        if self.get_option("RATE_LIMIT_TEST"):
            rate_limit_vulns = self.test_rate_limiting()
            vulnerabilities.extend(rate_limit_vulns)
        
        if self.get_option("ACCOUNT_LOCKOUT_TEST"):
            account_lockout_vulns = self.test_account_lockout()
            vulnerabilities.extend(account_lockout_vulns)
        
        if self.get_option("PASSWORD_RESET_TEST"):
            password_reset_vulns = self.test_password_reset()
            vulnerabilities.extend(password_reset_vulns)
        
        if self.get_option("OAUTH_MISCONFIG"):
            oauth_vulns = self.test_oauth_misconfig()
            vulnerabilities.extend(oauth_vulns)
        
        if self.get_option("JWT_TEST"):
            jwt_vulns = self.test_jwt()
            vulnerabilities.extend(jwt_vulns)
        
        if vulnerabilities:
            return {
                "success": True,
                "message": f"Found {len(vulnerabilities)} authentication vulnerabilities",
                "vulnerabilities": vulnerabilities
            }
        else:
            return {
                "success": True,
                "message": "No authentication vulnerabilities found"
            }
